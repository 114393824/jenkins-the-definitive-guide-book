<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="chapter-code-quality">
  <title>Code Quality</title>

  <sect1>
    <title>Introduction</title>

    <para><indexterm>
        <primary>code quality</primary>
      </indexterm>Few would deny the importance of writing quality code. High
    quality code contains less bugs, and is easier to understand and easier to
    maintain. However, the precise definitions of code quality can be more
    subjective, varying between organizations, teams, and even individuals
    within a team.</para>

    <para>This is where coding standards come into play. Coding standards are
    rules, sometimes relatively arbitrary, that define the coding styles and
    conventions that are considered acceptable within a team or organization.
    In many cases, agreeing on a set of standards, and applying them, is more
    important than the standards themselves. Indeed, one of the most important
    aspects of quality code is that it is easy to read and to understand. If
    developers within a team all apply the same coding standards and
    practices, the code will be more readable, at least for members of that
    team. And if the standards are commonly used within the industry, the code
    will also be more readable for new developers arriving on the team.</para>

    <para>Coding standards include both esthetic aspects such as code layout
    and formatting, naming conventions, and so forth, as well as potentially
    bad practices such as missing curly brackets after a condition in Java. A
    consistent coding style lowers maintenance costs, make code clearer and
    more readable, and makes it easier to work on code written by other team
    members.</para>

    <para>Only an experienced developer can really judge code quality in all
    its aspects. That is the role of code reviews and, among other things,
    practices like pair programming. In particular, only a human eye can
    decide if a piece of code is truly well written, and if it actually does
    what the requirements ask of it. However, code quality metrics tools can
    help a great deal. In fact it is unrealistic to try to enforce coding
    standards *without* the use of such tools.</para>

    <para>These tools analyze your application source code or byte code, and
    check whether the code respects certain rules. Code quality metrics can
    encompass many aspects of code quality, from coding standards and best
    practices right through to code coverage, with everything from compiler
    warnings to TODO comments in between. Certain metrics concentrate on
    measurable characteristics of your code base, such as the number of lines
    of code (NLOC), average code complexity, or the number of lines per class.
    Others focus on more sophisticated static analysis, or on looking for
    potential bugs or poor practices in your code.</para>

    <para>There are a wide range of code quality reporting plugins available
    for Hudson. Many are for Java static analysis tools, such as Checkstyle,
    PMD, FindBugs, Cobertura and JDepend. Others, such as fxcop and NCover,
    are focused on .NET applications.</para>

    <para>With all of these tools, you need to configure your build job to
    generate the code quality metrics data before Hudson can produce any
    reports.</para>

    <para>The notable exception to this rule is Sonar. Sonar can extract code
    quality metrics from any Maven project, with no additional configuration
    required in your Maven project. This is great when you have large numbers
    of existing Maven projects that you need to integrate into Hudson, and you
    want to configure consistent code quality reporting across all of your
    projects.</para>

    <para>In the rest of this chapter, we will see how to set up code quality
    reporting in your Hudson builds, and also how you can use it as an
    effective part of your build process.</para>
  </sect1>

  <sect1>
    <title>Code Quality in your build process</title>

    <para>Before we look at how to report on code quality metrics in Hudson,
    it can be useful to take a step back and look at the larger picture. Code
    Quality metrics are of limited value in isolation - they need to be part
    of a broader process improvement strategy.</para>

    <para>The first level of code quality integration should be the IDE.
    Modern IDEs have great support for many code quality tools - Checkstyle,
    PMD and FindBugs all have plugins for Eclipse, NetBeans and IntelliJ,
    which provide rapid feedback for developers on code quality issues. This
    is a much faster and more efficient way to provide feedback for individual
    developers, and to teach developers about the organizational or project
    coding standards.</para>

    <para>The second level is your build server. In addition to your normal
    unit and integration test build jobs, set up a dedicated code quality
    build, which runs after the normal build and test. The aim of this process
    is to produce project-wide code quality metrics, to keep tabs on how the
    project is doing as a whole, and to address any issues from a high level.
    The effectiveness of these reports can be increased by a weekly code
    quality review, in which code quality issues and trends are discussed
    within the team.</para>

    <para>It is important to run this job separately, because code coverage
    analysis and many static analysis tools can be quite slow to run. It is
    also important to keep any code coverage tests well away from builds, as
    the code coverage process produces instrumented code which should never be
    deployed to a repository for production use.</para>

    <para>Code quality reporting is, by default, a relatively passive process.
    No one will know the state of the project if they don't seek out the
    information on the build server. While this is better than nothing, if you
    are serious about code quality, there is a better way. Rather than simply
    reporting on code quality, set up a dedicated code quality build, which
    runs after the normal build and test, and configure the build to fail if
    code quality metrics are not at an acceptable level. You can do this in
    Hudson or in your build script, although one advantage of configuring this
    outside of your build script is that you can change code quality build
    failing criteria more easily without changing the project source
    code.</para>

    <para>As a final word, remember that coding standards are guidelines and
    recommendations, not absolute rules. Use failing code quality builds and
    code quality reports as indicators of a possible area of improvement, not
    as measurements of absolute value.</para>
  </sect1>

  <sect1>
    <title>Popular Code Quality Analysis tools</title>

    <para>There are many open source tools that can help identify poor coding
    practices.</para>

    <para>In the Java world, three static analysis tools have stood the test
    of time, and are widely used in very complementary ways. Checkstyle excels
    at checking coding standards and conventions, coding practices, as well as
    other metrics such code complexity. PMD is a static analysis tool similar
    to Checkstyle, more focused on coding and design practices. And FindBugs
    is an innovative tool issued from the ongoing research work of Bill Pugh
    and his team at the University of Maryland that focuses on identifying
    potentially dangerous and buggy code. And if you are working with Groovy
    or Grails, you can use CodeNarc, which checks Groovy coding practices and
    convention.</para>

    <para>All of these tools can be easily integrated into your build process.
    In the following sections, we will look at how to set up these tools to
    generate the XML reports that Hudson can then use for its own
    reporting.</para>

    <sect2>
      <title>Checkstyle</title>

      <para><command>Checkstyle</command>
      (<uri>http://checkstyle.sourceforge.net/</uri>) is a static analysis
      tool for Java. Originally designed to enforce a set of
      highly-configurable coding standards, Checkstyle now also lets you check
      for poor coding practices, as well as overly complex and duplicated
      code. Checkstyle is a versatile and flexible tool that should have its
      place in any Java-based code quality analysis strategy.</para>

      <para>Checkstyle supports a very large number of rules, including ones
      relating to naming conventions, annotations, javadoc comments, class and
      method size, code complexity metrics, poor coding practices and many
      others.</para>

      <para>Duplicated code is another important code quality issue -
      duplicated or near-duplicated code is harder to maintain and to debug.
      Checkstyle provides some support for the detection of duplicated code,
      but more specialized tools such as CPD do a better job in this
      area.</para>

      <para>One of the nice things about Checkstyle is how easy it is to
      configure. You can start off with the Sun coding conventions and tweak
      them to suit your needs, or start from scratch. Using the Eclipse plugin
      (or even directly in XML), you can pick and choose from several hundred
      different rules, and fine-tune the settings of the rules you do choose
      (see <xref linkend="fig-hudson-quality-checkstyle" />). This is
      important, as different organizations, teams and even projects have
      different requirements and preferences with regards to coding standards,
      and it is better to have a precise set of rules that can be adhered to,
      rather than a broad set of rules that will be ignored. It is especially
      important where large legacy code bases are involved - in these cases,
      it is often better to start off with a more limited set of rules than to
      be overwhelmed with a large number of relatively minor formatting
      issues.</para>

      <para><figure id="fig-hudson-quality-checkstyle">
          <title>It is easy to configure Checkstyle rules in Eclipse</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/hudson-quality-checkstyle.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>Configuring Checkstyle in your build is usually
      straight-forward. If you are using Ant, you need to download the
      checkstyle jar file from the website
      (<uri>http://checkstyle.sourceforge.net</uri>) and make it available to
      Ant. You could place it in your Ant <filename>lib</filename> directory,
      but this would mean customizing the Ant installation on your build
      server (and any slave nodes), so it is not a very portable solution. A
      better approach would be to place the Checkstyle jar file in one of your
      project directories, or to use Ivy or the Maven Ant Task library to
      declare a dependency on Checkstyle. If you opt for keeping the
      Checkstyle JAR file in the project directories, you could declare the
      Checkstyle task as shown here:</para>

      <para><programlisting><uri>&lt;taskdef resource="checkstyletask.properties"
         classpath="lib/checkstyle-5.3-all.jar"/&gt;</uri></programlisting></para>

      <para>Then, to generate Checkstyle reports in an XML format that Hudson
      can use, you could do the following:</para>

      <para><programlisting><uri>&lt;target name="checkstyle"&gt;
  &lt;checkstyle config="src/main/config/company-checks.xml"&gt;
    &lt;fileset dir="src/main/java" includes="**/*.java"/&gt; 
    &lt;formatter type="plain"/&gt; 
    &lt;formatter type="xml"/&gt;
  &lt;/checkstyle&gt;
&lt;/target&gt;</uri></programlisting></para>

      <para>Now, just invoke this task (e.g. <command>ant
      checkstyle</command>) to generate the Checkstyle reports.</para>

      <para>In Maven 2, you could add something like the following to the
      <code>&lt;reporting&gt;</code> section:<programlisting>&lt;reporting&gt;
  &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.4&lt;/version&gt;
        &lt;configuration&gt;
          &lt;configLocation&gt;
            src/main/config/company-checks.xml
          &lt;/configLocation&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/reporting&gt;</programlisting></para>

      <para>For a Maven 3 project, you need to add the plugin to the
      <code>&lt;reportPlugins&gt;</code> element of the
      <code>&lt;configuration&gt;</code> section of the
      <code>maven-site-plugin</code>:<programlisting>&lt;project&gt;
  &lt;properties&gt;
    &lt;sonar.url&gt;http://buildserver.acme.org:9000&lt;/sonar.url&gt;
  &lt;/properties&gt;
  &lt;build&gt;
    ...
     &lt;plugins&gt;
       ...
       &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0-beta-2&lt;/version&gt;
          &lt;configuration&gt;
            &lt;reportPlugins&gt;
              &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.4&lt;/version&gt;
                &lt;configuration&gt;
                  &lt;configLocation&gt;
                    ${sonar.url}/rules_configuration/export/java/My_Rules/checkstyle.xml
                  &lt;/configLocation&gt;
                &lt;/configuration&gt;
              &lt;/plugin&gt;
            &lt;/reportPlugins&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</programlisting></para>

      <para>Now, running <command>mvn checkstyle:checkstyle</command> or
      <command>mvn site</command> will analyse your source code and generate
      XML reports that Hudson can use.</para>

      <para>Note that in the last example, we used a Checkstyle ruleset that
      we have uploaded to a Sonar server (defined by the ${sonar.url}
      property). This strategy makes it easy to use the same set of Checkstyle
      rules for Eclipse, Maven, Hudson and Sonar.</para>

      <para>Recent versions of Gradle also offer some integrated Checkstyle
      support. In Gradle 0.8, you could set up Checkstyle for your builds as
      shown here:</para>

      <para><programlisting>apply plugin: 'code-quality'</programlisting></para>

      <para>This will use the checkstyle ruleset in
      <filename>config/checkstyle/checkstyle.xml</filename> by default. You
      can override this with the <code>checkstyleConfigFileName</code>
      property: at the time of writing, however, you can't get the Gradle code
      quality plugin to obtain the Checkstyle rules from a URL.</para>

      <para>You can generate the Checkstyle reports here by running
      <command>gradle checkstyleMain</command> or <command>gradle
      check</command>.</para>
    </sect2>

    <sect2>
      <title>PMD/CPD</title>

      <para>PMD (<uri>http://pmd.sourceforge.org</uri>) is another popular
      static analysis tool. It focuses on potential coding problems such as
      unused or sub-optimal code, code size and complexity, and good coding
      practices. Some typical rules include "Empty If Statement", "Broken Null
      Check", "Avoid Deeply Nested If Statements", "Switch Statements Should
      Have Default", and "Logger Is Not Static Final". There is a fair amount
      of overlap with some of the Checkstyle rules, though PMD does have some
      more technical rules, and more specialized ones such as rules related to
      JSF and Android.</para>

      <para>PMD also comes with CPD, a robust open source detector of
      duplicated and near-duplicated code.</para>

      <para>PMD is a little less flexible than Checkstyle, though you can
      still pick and choose the rules you want to use in Eclipse, and then
      export them as an XML file (see <xref
      linkend="fig-hudson-quality-pmd" />). You can then import this rule set
      into other Eclipse projects, into Sonar, or use it in your Ant or Maven
      builds.</para>

      <para><figure id="fig-hudson-quality-pmd">
          <title>Configuring PMD rules in Eclipse</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/hudson-quality-pmd.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>PMD comes with an Ant task that you can use to generate the PMD
      and CPD reports. First, though, you need to define these tasks, as shown
      in the following example:<programlisting>&lt;path id="pmd.classpath"&gt;
    &lt;pathelement location="${build}"/&gt;
    &lt;fileset dir="lib/pmd"&gt;
        &lt;include name="*.jar"/&gt;
    &lt;/fileset&gt;
&lt;/path&gt;

&lt;taskdef name="pmd" classname="net.sourceforge.pmd.ant.PMDTask" 
         classpathref="pmd.classpath"/&gt;

 &lt;taskdef name="cpd" classname="net.sourceforge.pmd.cpd.CPDTask" 
          classpathref="pmd.classpath"/&gt;</programlisting>Next, you can
      generate the PMD XML report by invoking the PMD task as illustrated here
      (using some :</para>

      <para><programlisting>&lt;target name="pmd"&gt;
 &lt;taskdef name="pmd" classname="net.sourceforge.pmd.ant.PMDTask" 
          classpathref="pmd.classpath"/&gt;

 &lt;pmd rulesetfiles="basic" shortFilenames="true"&gt;
  &lt;formatter type="xml" toFile="target/pmd.xml" /&gt;
  &lt;fileset dir="src/main/java" includes="**/*.java"/&gt; 
 &lt;/pmd&gt;
&lt;/target&gt;</programlisting></para>

      <para>And, to generate the CPD XML report, you could do something like
      this:</para>

      <para><programlisting>&lt;target name="cpd"&gt;
  &lt;cpd minimumTokenCount="100" format="xml" outputFile="/target/cpd.xml"&gt;
    &lt;fileset dir="src/main/java" includes="**/*.java"/&gt; 
  &lt;/cpd&gt;
&lt;/target&gt;</programlisting>You can place this XML ruleset in your project
      classpath (for example, in <code>src/main/resources</code> for a Maven
      project), or in a separate module (if you want to share the
      configuration between projects).An example of how to configure Maven 2
      to generate PMD and CPD reports using an exported XML ruleset as shown
      here:</para>

      <para><programlisting>&lt;reporting&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
      &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;
      &lt;version&gt;2.5&lt;/version&gt;
      &lt;configuration&gt;
        &lt;!-- PMD options --&gt;
        &lt;targetJdk&gt;1.6&lt;/targetJdk&gt;
        &lt;aggregate&gt;true&lt;/aggregate&gt;
        &lt;format&gt;xml&lt;/format&gt;
        &lt;rulesets&gt;
          &lt;ruleset&gt;/pmd-rules.xml&lt;/ruleset&gt;
        &lt;/rulesets&gt;

        &lt;!-- CPD options --&gt;
        &lt;minimumTokens&gt;20&lt;/minimumTokens&gt;
        &lt;ignoreIdentifiers&gt;true&lt;/ignoreIdentifiers&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/reporting&gt;</programlisting></para>

      <para>If you are using Maven 3, you would place the plugin definition in
      the <code>&lt;maven-site-plugin&gt;</code> configuration section, as
      shown below. This example also shows how to use a ruleset in another
      dependency (in this case the <code>pmd-rules.jar</code> file):</para>

      <para><programlisting>&lt;project&gt;
  ...
  &lt;build&gt;
    ...
     &lt;plugins&gt;
       ...
       &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0-beta-2&lt;/version&gt;
          &lt;configuration&gt;
            &lt;reportPlugins&gt;
              &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-pmd-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.5&lt;/version&gt;
                &lt;configuration&gt;
                  &lt;!-- PMD options --&gt;
                  &lt;targetJdk&gt;1.6&lt;/targetJdk&gt;
                  &lt;aggregate&gt;true&lt;/aggregate&gt;
                  &lt;format&gt;xml&lt;/format&gt;
                  &lt;rulesets&gt;
                    &lt;ruleset&gt;/pmd-rules.xml&lt;/ruleset&gt;
                  &lt;/rulesets&gt;

                  &lt;!-- CPD options --&gt;
                  &lt;minimumTokens&gt;50&lt;/minimumTokens&gt;
                  &lt;ignoreIdentifiers&gt;true&lt;/ignoreIdentifiers&gt;
                &lt;/configuration&gt;
              &lt;/plugin&gt;
            &lt;/reportPlugins&gt;
          &lt;/configuration&gt;
          &lt;dependencies&gt;
            &lt;dependency&gt;
              &lt;groupId&gt;com.wakaleo.code-quality&lt;/groupId&gt;
              &lt;artifactId&gt;pmd-rules&lt;/artifactId&gt;
              &lt;version&gt;1.0.1&lt;/version&gt;
            &lt;/dependency&gt;
          &lt;/dependencies&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</programlisting></para>

      <para>Now, you can run either <command>mvn site</command> or
      <command>mvn pmd:pmd pmd:cpd</command> to generate the PMD and CPD
      reports.</para>

      <para>Unfortunately there is currently no built-in Gradle support for
      PMD or CPD, so you have to fall back on invoking the PMD Ant plugin
      directly, as shown here:</para>

      <para><programlisting>configurations {
    pmdConf
}

dependencies {
    pmdConf 'pmd:pmd:4.2.5'
}

task pmd &lt;&lt; {
    println 'Running PMD static code analysis'
    ant {
        taskdef(name:'pmd', classname:'net.sourceforge.pmd.ant.PMDTask', 
                classpath: configurations.pmdConf.asPath)

        taskdef(name:'cpd', classname:'net.sourceforge.pmd.cpd.CPDTask', 
                        classpath: configurations.pmdConf.asPath)

        pmd(shortFilenames:'true', failonruleviolation:'false', 
            rulesetfiles:'conf/pmd-rules.xml') {
            formatter(type:'xml', toFile:'build/pmd.xml')
            fileset(dir: "src/main/java") {
                include(name: '**/*.java')
            }
            fileset(dir: "src/test/java") {
                include(name: '**/*.java')
            }
        }

        cpd(minimumTokenCount:'50', format: 'xml',
            ignoreIdentifiers: 'true',
            outputFile:'build/cpd.xml') {
            fileset(dir: "src/main/java") {
                include(name: '**/*.java')
            }
            fileset(dir: "src/test/java") {
                include(name: '**/*.java')
            }        
        }
    }
}</programlisting>This configuration will use the PMD rule set in the
      <filename>src/config</filename> directory, and generate a PMD XML report
      called '<filename>pmd.xml</filename>' in the <filename>build</filename>
      directory. It will also run CPD and generate a CPD XML report called
      '<filename>cpd.xml</filename>' in the <filename>build</filename>
      directory.</para>
    </sect2>

    <sect2>
      <title>FindBugs</title>

      <para>FindBugs is a powerful code quality analysis tool that checks your
      application byte code for potential bugs, performance problems, or poor
      coding habits. FindBugs is the result of research carried out at the
      University of Maryland lead by Bill Pugh, which studies byte code
      patterns coming from bugs in large real-world projects, such as the
      JDKs, Eclipse, and source code from Google applications. FindBugs can
      detect some fairly significant issues such as null pointer exceptions,
      infinite loops, and unintentionally accessing the internal state of an
      object. Unlike many other static analysis tools, FindBugs tends to find
      a smaller number of issues, but of those issues, a larger proportion
      will be important.</para>

      <para>FindBugs is less configurable than the other tools we have seen,
      though in practice you generally don't need to fine-tune the rules as
      much as the other tools we've discussed. You can list the individual
      rules you want to apply, but you can't configure a shared XML file
      between your Maven builds and your IDE, for example.</para>

      <para>FindBugs comes bundled with an Ant task. You can define the
      FindBugs task in Ant as shown below. FindBugs needs to refer to the
      FindBugs home directory, which is where the binary distribution of
      FindBugs has been unzipped. To make the build more portable, we are
      storing the FindBugs installation in our project directory structure, in
      the <filename>tools/findbugs</filename> directory.</para>

      <para><programlisting>&lt;property name="findbugs.home" value="tools/findbugs" /&gt;

&lt;taskdef name="findbugs" classname="edu.umd.cs.findbugs.anttask.FindBugsTask" &gt; 
  &lt;classpath&gt;
    &lt;fileset dir="${findbugs.home}/lib" includes="**/*.jar"/&gt;
  &lt;/classpath&gt;
&lt;/taskdef&gt;</programlisting></para>

      <para>Then, to run FindBugs, you could set up a "findbugs" target as
      shown below. Note that FindBugs runs against your application byte-code,
      not your source code, so you need to compile your source code
      first.</para>

      <para><programlisting>&lt;target name="findbugs" depends="compile"&gt; 
  &lt;findbugs home="${findbugs.home}" output="xml" outputFile="target/findbugs.xml"&gt;
    &lt;class location="${classes.dir}" /&gt; 
    &lt;auxClasspath refId="dependency.classpath" /&gt; 
    &lt;sourcePath path="src/main/java" /&gt;
  &lt;/findbugs&gt;
&lt;/target&gt;</programlisting>If you are using Maven 2, you don't need to
      keep a local copy of the FindBugs installation. You just need to
      configure FindBugs in the reporting section as shown
      here:<programlisting>&lt;reporting&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
      &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;2.2&lt;/version&gt;
      &lt;configuration&gt;
        &lt;effort&gt;Max&lt;/effort&gt;
        &lt;xmlOutput&gt;true&lt;/xmlOutput&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/reporting&gt;</programlisting></para>

      <para>Or for a Maven 3 project:</para>

      <para><programlisting>&lt;project&gt;
  ...
  &lt;build&gt;
    ...
     &lt;plugins&gt;
       ...
       &lt;plugin&gt;
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
          &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0-beta-2&lt;/version&gt;
          &lt;configuration&gt;
            &lt;reportPlugins&gt;
                &lt;plugin&gt;
                  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
                  &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;
                  &lt;version&gt;2.3.1&lt;/version&gt;
                  &lt;configuration&gt;
                    &lt;effort&gt;Max&lt;/effort&gt;
                    &lt;xmlOutput&gt;true&lt;/xmlOutput&gt;
                  &lt;/configuration&gt;
                &lt;/plugin&gt;
            &lt;/reportPlugins&gt;
          &lt;/configuration&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</programlisting>In both cases, you can generate the XML
      reports by running <command>mvn site</command> or <command>mvn
      findbugs:findbugs</command>. The XML reports will be placed in the
      <filename>target</filename> directory.</para>

      <para>At the time of writing there is no special support for FindBugs in
      Gradle, so you need to invoke the FindBugs Ant plugin.</para>
    </sect2>

    <sect2>
      <title>CodeNarc</title>

      <para>CodeNarc is a static analysis tool for Groovy code, similar to PMD
      for Java. It checks Groovy source code for potential defects, poor
      coding practices and styles, overly complex code, and so on. Typical
      rules include "Constant If Expression", "Empty Else Block", "GString As
      Map Key", and "Grails Stateless Service".</para>

      <para>For Ant or Maven-based projects, the CodeNarc Ant plugin is the
      simplest option (a Maven plugin is under development at the time of
      writing). A typical Ant configuration for use with Hudson would like
      like this:<programlisting>&lt;taskdef name="codenarc" classname="org.codenarc.ant.CodeNarcTask"/&gt;
&lt;target name="runCodeNarc"&gt;
    &lt;codenarc ruleSetFiles="rulesets/basic.xml,rulesets/exceptions.xml,rulesets/imports.xml"
              maxPriority1Violations="0"&gt;

        &lt;report type="xml"&gt;
            &lt;option name="outputFile" value="reports/CodeNarc.xml" /&gt;
        &lt;/report&gt;

        &lt;fileset dir="src"&gt;
            &lt;include name="**/*.groovy"/&gt;
        &lt;/fileset&gt;
    &lt;/codenarc&gt;
&lt;/target&gt;</programlisting></para>

      <para>You can integrate CodeNarc into a Grails project simply by
      installing the CodeNarc Plugin:</para>

      <para><programlisting>$ grails install-plugin codenarc</programlisting>This
      will configure CodeNarc to analyse the Groovy files in your Grails
      application code, as well as in the <filename>src/groovy</filename> and
      <filename>test</filename> directories.</para>

      <para>Gradle 0.8 also provides support for CodeNarc in the code-quality
      plugin, that you can configure in your builds as shown here:</para>

      <para><programlisting>apply plugin: 'code-quality'</programlisting></para>

      <para>This will use the CodeNarc configuration file in
      <filename>config/codenarc/codenarc.xml</filename> by default. You can
      override this with the <code>codeNarcConfigFileName</code>
      property.</para>

      <para>You can generate the CodeNarc reports here by running
      <command>gradle codenarcMain</command> or, more simply, <command>gradle
      check</command>.</para>
    </sect2>
  </sect1>

  <sect1 id="sect-violations">
    <title>Reporting on Code Quality issues with the Violations plugin</title>

    <para>One of the most useful code quality plugins for Hudson is the
    Violations plugin. This plugin will not analyse your project source code
    (you need to configure your build to do that), but it does a great job on
    reporting on the code quality metrics generated for individual builds and
    trends over time. The plugin caters for reports on code quality metrics
    coming from a large range of static analysis tools, including:</para>

    <variablelist>
      <varlistentry>
        <term>For Java</term>

        <listitem>
          <para>Checkstyle, CPD, PMD and FindBugs, and also jcreport</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>For Groovy</term>

        <listitem>
          <para>codenarc</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>For JavaScript</term>

        <listitem>
          <para>jslint</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>For .Net</term>

        <listitem>
          <para>gendarme and stylecop</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Installing the plugin is straight-forward. Just go to the 'Plugin
    Manager' screen and select the 'Hudson Violations plugin'. Once you have
    installed the plugin and restarted Hudson, you will be able to use it for
    your projects.</para>

    <para>The Violations plugin does not generate the code quality metrics
    data itself - you need to configure your built to do that, as shown in the
    previous section. An example of doing this for a Maven build job is
    illustrated in <xref linkend="fig-hudson-quality-goals" />. Notice that
    here we are invoking the Maven plugin goals directly. We could also just
    run <command>mvn site</command>, but if we are only interested in the code
    quality metrics, and not the other elements of the Maven-generated site,
    calling the plugins directly will result in faster builds.</para>

    <para><figure id="fig-hudson-quality-goals">
        <title>Generating code quality reports in a Maven build</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/fig-hudson-quality-goals.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>Once you have set this up, you can configure the violations
    plugin to generate reports and, if required, trigger notifications, based
    on the report results. Just go to the <command>Post-build
    Actions</command> and check the 'Report Violations' checkbox. The details
    of the configuration vary depending on the project type. Lets look at
    Freestyle build jobs first.</para>

    <sect2>
      <title>Working with Freestyle build jobs</title>

      <para>Freestyle build jobs allow you the most configuration flexibility,
      and are your only option for non-Java projects.</para>

      <para>When you use the Violations plugin with a Freestyle build job, you
      need to specify the paths to each of the XML reports generated by the
      static analysis tools you have used (see <xref
      linkend="fig-hudson-quality-freestyle-violations" />). The plugin can
      cater for several reports from the same tool, which is useful for Maven
      multi-module projects - just use a wildcard expression to identify the
      reports you want (for example,
      <filename>**/target/checkstyle.xml</filename>)</para>

      <para><figure id="fig-hudson-quality-freestyle-violations">
          <title>Configuring the violations plugin for a Freestyle
          project</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/hudson-quality-violations.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>The Violations plugin will generate a graph tracking the
      number of each type of issue over time (see <xref
      linkend="fig-hudson-quality-violations-graph" />). The graph displays a
      different-colored line for each type of violations your are tracking, as
      well as a summary of the latest results.</para>

      <para><figure id="fig-hudson-quality-violations-graph">
          <title>Violations over time</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/hudson-quality-violations-graph.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>You can also click on this graph to drill down into a particular
      build. Here, you can see number of issues raised for that particular
      build (see <xref linkend="fig-hudson-quality-violations-build" />), with
      various breakdowns by violation type, severity, and by file.</para>

      <para><figure id="fig-hudson-quality-violations-build">
          <title>Violations for a given build</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/hudson-quality-violations-build.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>Finally, you can drill down into a particular class, to
      display the detailed list of issues, along with where they appear in the
      source code.</para>

      <para>But the Violations plugins also allows for a more proactive
      management of code quality. You can use the results of the code quality
      analysis reports to influence the weather icon on the Hudson dashboard.
      This weather icon is normally related to the number of failing builds in
      the previous five builds, but Hudson can also take into account other
      factors, such as code quality results. Displaying a cloudy or stormy
      icon for a project on the dashboard is a much better way of raising
      awareness about code quality issues that simply relying on graphs and
      reports on the build job page.</para>

      <para>To set this up, you need to go back to the <command>Report
      Violations</command> section in the <command>Post-build
      Actions</command>. The first three columns in <xref
      linkend="fig-hudson-quality-freestyle-violations" /> show a sunny icon,
      a stormy icon, and a yellow ball. The one with the sunny icon is the
      maximum number of violations tolerated in order to keep the sunny
      weather icon on the dashboard page. The second column, with the stormy
      weather icon, is the number of violations that will cause a stormy icon
      to appear on the dashboard. If you have a number of violations between
      these two extremes, you will get one of the cloudy icons.</para>

      <para>You can set different values for different tools. The exact
      thresholds will vary between teams and between projects, and also
      between tools. For example, Checkstyle will typically raise a lot more
      issues than FindBugs or CPD, with PMD being somewhere in-between. You
      need to adjust the values you use to reflect how these tools work on
      your code base, and your expectations.</para>

      <para>You can take this even further with the third column (the one with
      the yellow ball). This column lets you set a number of violations that
      will cause the build to be declared unstable. Remember, when a build
      becomes unstable Hudson will send out notification messages, so this is
      an even more proactive strategy.</para>

      <para>For example, in <xref
      linkend="fig-hudson-quality-freestyle-violations" />, we have configured
      the minimum number of Checkstyle violations to 10, which means that the
      sunny weather icon will only appear if there are ten or fewer Checkstyle
      violations. If there are more than 10, the weather will degrade
      progressively, until at the 200 violations mark, it will become stormy.
      And if there are 500 or more Checkstyle violations, the project will be
      flagged as unstable.</para>

      <para>Now look at the configuration for CPD, the duplicated code
      detector that comes with PMD. In this project, we have adopted a
      zero-tolerance policy for duplicated code, so the sunny icon value is
      set to zero. The stormy icon is set to 10, so if there are 10 or more
      copy-paste violations, the project weather indicator will appear as
      stormy. And if the project has 15 or more copy-paste violations, it will
      be declared unstable.</para>

      <para>Now, on the Dashboard page, this project will appear both with a
      stormy weather icon and as unstable, even though there are no test
      failures (see <xref
      linkend="fig-hudson-quality-violations-rollover" />). This particular
      build is unstable because there are 16 CPD violations. In addition, if
      you place your mouse over the weather icon, Hudson will display some
      more details about how it calculated this particular status</para>

      <para><figure id="fig-hudson-quality-violations-rollover">
          <title>Configuring the violations plugin for a Freestyle
          project</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/hudson-quality-violations-rollover.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Working with Maven build jobs</title>

      <para>Maven build jobs in Hudson use the Maven conventions and
      information in the project <filename>pom.xml</filename> file to make
      configuration easier and more light-weight. When you use the Violations
      plugin with a Maven build job, Hudson uses these conventions to reduce
      the amount of work you need to do to configure the plugin. You don't
      need to tell Hudson where to find the XML reports for many of the static
      analysis tools (for example, Checkstyle, PMD, FindBugs and CPD), as
      Hudson can figure thia out based from the Maven conventions and plugin
      configurations (see <xref linkend="fig-hudson-maven-violations" />). If
      you do need to override these conventions, you can choose the 'Pattern'
      option in the 'XML filename pattern' drop-down list, and enter a path as
      you do for freestyle build jobs.</para>

      <para><figure id="fig-hudson-maven-violations">
          <title>Configuring the violations plugin for a Maven project</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/hudson-maven-violations.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The Violations plugin works well with multi-module Maven projects,
      but at the time of writing it needs a little tweaking to obtain best
      results. Maven build jobs understand the structure of multi-module
      projects (see <xref linkend="fig-hudson-maven-modules" />); furthermore,
      you can drill down into any module and get a detailed view of the build
      results for that build job.</para>

      <para><figure id="fig-hudson-maven-modules">
          <title>Hudson Maven build jobs understand Maven multi-module
          structures</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/hudson-maven-modules.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>This is a very useful feature, but it means you need to do a
      little extra work to get all of the benefits out of the Violations
      plugins for the individual modules. By default, the violations plugin
      will display an aggregated view of the code quality metrics like the one
      in <xref linkend="fig-hudson-quality-violations-graph" />. You can also
      click on the violations graph, and view the detailed reports for each
      module.</para>

      <para>However, for this to work correctly, you need to activate the
      violations plugin individually for each module in addition to the main
      project. To do this, click on the module you want to configure in the
      Modules screen, and then click on the 'Configure' menu. Here, you will
      see a small subset of the usual configuration options (see <xref
      linkend="fig-hudson-violations-module-config" />). Here, you just need
      to activate the 'Violations' option, and configure the thresholds if
      required. On the positive side, this means that you can define different
      threshold values for different modules.</para>

      <para><figure id="fig-hudson-violations-module-config">
          <title>Activating the Violations plugin for an individual
          module</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/hudson-violations-module-config.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>Once you have done this, when you click on the violations
      aggregate graph on the project build job home page, Hudson will list the
      individual violations graphs for each module.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Using the Checkstyle, PMD and FindBugs reports</title>

    <para>You can also report individually on results from Checkstyle, PMD and
    FindBugs. In addition to the Violations plugin, there are also Hudson
    plugins that produce trend graphs and detailed reports for each of these
    tools individually. We will look at how to do this for Checkstyle, but the
    same approach also applies for PMD and FindBugs. You can even use the
    Analysis Collector Plugin to display the combined results in a graph
    similar to the one produced by the Violations plugin.</para>

    <para>You can install these plugins through the Plugin Manager in the
    usual way. The plugins in question are called, unsurprisingly, "Checkstyle
    Plugin", "PMD Plugin", and "FindBugs Plugin". All of these plugins use the
    Static Analysis Utilities plugin, which you need to install as well (see
    <xref linkend="fig-hudson-analysis-plugins" />). </para>

    <para><figure id="fig-hudson-analysis-plugins">
        <title>Installing the Checkstyle and Static Analysis Utilities
        plugins</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-analysis-plugins.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>Once you have installed these plugins, you can set up the
    reporting in your project configuration. Tick the 'Publish Checkstyle
    analysis results' checkbox. In a freestyle build, you will need to specify
    a path pattern to find the Checkstyle XML reports; in a Maven 2 build,
    Hudson will figure out where to look for them by itself. </para>

    <para>This will provide basic Checkstyle reporting, but as usual you can
    fine-tune things further by clicking on the 'Advanced' button. In a Maven
    2 build, you can configure the health threshold values (how many
    violations will cause the build to go from sunny to stormy), and also
    filter the priority violations you want to include in this calculation.
    For example, you may only want high priority issues to be taken into
    account for the weather icon status.</para>

    <para>The Freestyle builds have a few more options you can configure: in
    particular, you can cause the build to become unstable (yellow ball) or
    even to fail (red ball) if there are more than a given number of
    violations, or if there are more than a given number of new violations
    (see <xref linkend="fig-hudson-checkstyle-config" />). So, in the
    configuration in the illustration, if there are more than 50 new
    checkstyle violations of any priority in a build, the build will be
    flagged as unstable. This certainly has its uses for Checkstyle, but it
    can also come in very handy with FindBugs, where high priority issues
    often represent dangerous and potentially show-stopping bugs.</para>

    <para><figure id="fig-hudson-checkstyle-config">
        <title>Configuring the Checkstyle plugin</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-checkstyle-config.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>Now, when the build runs, Hudson will now generate a trend
    graph and detailed reports for the Checkstyle violations (see <xref
    linkend="fig-hudson-checkstyle-trend" />). From here, you can drill down
    to see violations per priority, per category, per run type, per package,
    and so on.</para>

    <para><figure id="fig-hudson-checkstyle-trend">
        <title>Configuring the Checkstyle plugin</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-checkstyle-trend.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>As we mentioned earlier, the same approach also works with the
    'PMD Plugin' and the 'FindBugs Plugin'. These plugins are a great way to
    provide more focused reporting on the results of a particular tool, and
    also give you more control over the impact that these violations will have
    on the build results.</para>
  </sect1>

  <sect1>
    <title>Reporting on Code Complexity</title>

    <para>Code complexity is another important aspect of code quality. Code
    complexity is measured in a number of ways, but one commonly used (and
    easy-to-understand) complexity metric is Cyclometric Complexity, which
    involves measuring the number of different paths through a method. Using
    this metric, complex code typically has large numbers of nested
    conditional statements and loops, which make the code harder to understand
    and to debug.</para>

    <para>There is also a code quality theory that correlates code complexity
    and code coverage, to give a general idea of how reliable a particular
    piece of code is. This is based on the (very understandable) idea that
    code that is both complex and poorly tested is more likely to contain bugs
    than simple, well-tested code.</para>

    <para>The 'Coverage Complexity Scatter Plot Plugin' is designed to let you
    visualize this information in your Hudson builds (see <xref
    linkend="fig-hudson-coverage-complexity" />). Dangerously complex and/or
    untested methods will appear high on the graph, where as the more
    well-written and well-tested methods will appear lower down.</para>

    <para><figure id="fig-hudson-coverage-complexity">
        <title>A coverage/complexity scatter plot</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-coverage-complexity.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>The scatter graph gives you a good overview of the state of your
    code in terms of complexity and test coverage, but you can also drill down
    to investigate further. If you click on any point in the graph, you can
    see the corresponding methods, with their test coverage and complexity
    (see <xref linkend="fig-hudson-coverage-complexity-details" />).</para>

    <para><figure id="fig-hudson-coverage-complexity-details">
        <title>You can click on any point in the graph to investigate
        further</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-coverage-complexity-details.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>At the time of writing, this plugin requires Clover, so your
    build needs to have generated a Clover XML coverage report, and you need
    to have installed and configured the Clover Hudson Plugin (see <xref
    linkend="sect-clover" />). However support for Cobertura and other tools
    is planned.</para>
  </sect1>

  <sect1>
    <title>Reporting on open tasks</title>

    <para>When it comes to code quality, static analysis is not the only tool
    you can use. Another indicator of the general health of your project can
    be found in the number of FIXME, TODO, @deprecated, and similar tags
    scattered through the source code. If there are a lot of these, it can be
    a sign that your code base has a lot of unfinished work, and is therefore
    not in a very finalized state.</para>

    <para>The Hudson Task Scanners plugin lets you keep track of these sorts
    of tags in your source code, and optionally flag a build with a bad
    weather icon on the dashboard if there are too many open tasks.</para>

    <para>To set this up, you need to install both the ' Static Analysis
    Utilities' plugin and the 'Task Scanner Plugin'. Once installed, you can
    activate the plugin in your project by checking the 'Scan workspace for
    open tasks' checkbox in the <command>Build Settings</command> section of
    your project job configuration.</para>

    <para>Configuring the Task Scanner plugin is pretty straightforward (see
    <xref linkend="fig-hudson-task-scanner" />). You simply enter the tags you
    want to track, with different priorities if you consider certain tags to
    be more important than others. By default, the plugin will scan all the
    Java source code in the project, but you can redefine this behavior by
    entering the 'Files to scan' field. In <xref
    linkend="fig-hudson-task-scanner" />, for example, we also check XML and
    JSP files for tags.</para>

    <para><figure id="fig-hudson-task-scanner">
        <title>Configuring the Task Scanner plugin is straightforward</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-task-scanner.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>The 'Advanced' button gives you access to a few more
    sophisticated options. Probably the most useful are the Health thresholds,
    which let you define the maximum number of issues tolerated before the
    build can no longer be considered "sunny", and the minimum number of
    issues required for "stormy weather" status.</para>

    <para>The plugin generates a graph that shows tag trends by priority (see
    <xref linkend="fig-hudson-task-scanner-report" />). If you click on the
    'Open Tasks' report, you can also see a breakdown of tasks by Maven
    module, package or file, or even list the open tasks.</para>

    <para><figure id="fig-hudson-task-scanner-report">
        <title>The Open Tasks Trend graph</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-task-scanner-report.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>
  </sect1>

  <sect1>
    <title>Integrating with Sonar</title>

    <para>Sonar (<uri>http://www.sonarsource.org/</uri>) is a tool that
    centralizes a range of code quality metrics into a single web site (see
    <xref linkend="fig-hudson-sonar" />). It uses several Maven plugins
    (Checkstyle, PMD, FindBugs, Cobertura or Clover, and others) to analyse
    Maven projects and generate a comprehensive set of code quality metrics
    reports. Sonar reports on code coverage, rule compliance, and
    documentation, but also on more high-level metrics such as complexity,
    maintainability and even technical debt. You can use plugins to extend its
    features and add support for other languages (such as support for CodeNarc
    for Groovy source code). The rules used by the various tools are managed
    and configured centrally on the Sonar web site, and the Maven projects
    being analysed don't require any particular configuration. This makes
    Sonar a great fit for working on Maven projects where you have limited
    control over the pom files.</para>

    <para><figure id="fig-hudson-sonar">
        <title>Code quality reporting by Sonar</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center" fileref="figs/web/hudson-sonar.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Sonar works by running a set of Maven code quality related plugins
    against your Maven project, and storing the results into a relational
    database. The Sonar server, which you run separately, then analyses and
    displays the results as shown in <xref
    linkend="fig-hudson-sonar" />.</para>

    <para>Hudson integrates well with Sonar. The Hudson Sonar Plugin lets you
    define Sonar instances for all of your projects, and then activate Sonar
    in particular builds. You can run your Sonar server on a different machine
    to your Hudson instance, or on the same. The only constraint is that the
    Hudson instance must have JDBC access to the Sonar database, as it injects
    code quality metrics directly into the database, without going through the
    Sonar web site (see <xref
    linkend="fig-hudson-sonar-architecture" />).</para>

    <para><figure id="fig-hudson-sonar-architecture">
        <title>Hudson and Sonar</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-sonar-architecture.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>You install the plugin in the usual way, via the Plugin
    Manager. Once installed, you configure the Hudson Sonar Plugin in the
    <command>Configure System</command> screen, in the
    <command>Sonar</command> section. This involves defining your Sonar
    instances - you can configure as many instances of Sonar as you need. The
    default configuration assumes that you are running a local instance of
    Sonar with the default embedded database. This is useful for testing
    purposes but not very scalable. For a production environment, you will
    typically run Sonar on a real database such as MySQL or Postgres, and you
    will need to configure the JDBC connection to the production Sonar
    database in Hudson. You do this by clicking on the 'Advanced' button and
    filling in the appropriate fields (see <xref
    linkend="fig-hudson-sonar-config" />).</para>

    <para><figure id="fig-hudson-sonar-config">
        <title>Configuring Sonar in Hudson</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-sonar-config.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>The other thing you need to configure is when the Sonar build
    will kick off in a Sonar-enabled build job. You usually configure Sonar to
    run with one of the long-running Hudson build jobs, such as the code
    quality metrics build. It is not very useful to run the Sonar build more
    than once a day, as Sonar stores metrics in 24-hour slices. The default
    configuration will kick off a Sonar build in a Sonar-enabled build job
    whenever the job is triggered by a periodically scheduled build or by a
    manual build.</para>

    <para>To activate Sonar in your build job with the system-wide
    configuration options, just check the 'Sonar' option in the
    <command>Post-build Actions</command> (see <xref
    linkend="fig-hudson-sonar-config-job" />). Sonar will run whenever your
    build is started by one of the trigger mechanisms defined above.</para>

    <para><figure id="fig-hudson-sonar-config-job">
        <title>Configuring Sonar in a build job</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-sonar-config-job.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>You typically set up Sonar to run on a regular basis, for
    example every night or once a week. So you can activate Sonar on your
    normal unit/integration test build job, simply by adding a (see <xref
    linkend="fig-hudson-sonar-build-schedule" />). This avoids duplicated
    configuration details between jobs. Or, if you already have a scheduled
    build job that runs with an appropriate frequency (such as a dedicated
    code quality metrics build), you can activate Sonar on this build
    job.<figure id="fig-hudson-sonar-build-schedule">
        <title>Scheduling Sonar builds</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-sonar-build-schedule.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>If you click on the 'Advanced' button, you can specify other more
    sophisticated options, such as running your Sonar build on a separate
    branch, passing Maven additional command-line options (such as extra
    memory), or overriding the default trigger configuration</para>

    <para>By default, Sonar will run even if the normal build fails. This is
    usually what you want, as Sonar should record build and test failures as
    well as successful results. However, if required, you can deactivate this
    option too in the Advanced options.</para>
  </sect1>

  <sect1>
    <title>Conclusion</title>

    <para>Code quality is an important part of the build process, and Hudson
    provides excellent support for the wide range of code quality-related
    tools out there. As a result, Hudson should be a key part of your code
    quality strategy.</para>
  </sect1>
</chapter>
