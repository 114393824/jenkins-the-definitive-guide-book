<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="chapter-advanced-builds">
  <title>Advanced Builds</title>

  <sect1>
    <title>Introduction</title>

    <para><indexterm>
        <primary>Advanced builds</primary>
      </indexterm>In this chapter, we will look at some more advanced build
    job setups.</para>
  </sect1>

  <sect1>
    <title>Parameterized build jobs</title>

    <para>Parameterized builds are a powerful concept that enable you to add
    another dimension to your build jobs.</para>

    <para>The <command>Parameterized Build</command> plugin lets you configure
    parameters for your build job, that can be either entered by the user when
    the build job is triggered, or (as we will see later) from another build
    job.</para>

    <para>For example, you might have a deployment build job, where you want
    to choose the target environment in a drop-down list when you start the
    build job. Or you may want to specify the version of the application you
    want to deploy. Or, when running a build job involving web tests, you
    might want to specify the browser to run your Selenium or WebDriver tests
    in. You can even upload a file to be used by the build job.</para>

    <sect2>
      <title>Creating a parameterized build jobs</title>

      <para>You install the Parameterized Build plugin as usual, via the
      Plugin Manager screen. Once you have done this, configuring a
      parameterized build job is straight-forward. Just tick the 'This build
      is parameterized' option and click 'Add Parameter' to add a new build
      job parameter (see <xref linkend="fig-hudson-parameterized-build" />).
      You can add parameters to any sort of build, and you can add as many
      parameters as you want for a given build job.</para>

      <para><figure id="fig-hudson-parameterized-build">
          <title>Creating a parameterized build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-parameterized-build.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>To add a parameter to your build job, just pick the parameter type
      in the drop-down list. This will let you configure the details of your
      parameter (see <xref linkend="fig-hudson-string-build-parameter" />).
      You can choose from several different parameter types, such as Strings,
      Booleans, and drop-down lists. Depending on the type you choose, you
      will have to enter slightly different configuration values, but the
      basic process is identical. All parameter types, with the exception of
      the File parameter (see below), have a name and a description, and most
      often a default value.</para>

      <para>In <xref linkend="fig-hudson-enter-string-parameter" />, for
      example, we are adding a parameter called <command>version</command> to
      a deployment build job. The default value ("RELEASE") will be initially
      displayed when Jenkins prompts the user for this parameter, so if the
      user doesn't change anything, this value will be used.</para>

      <para><figure id="fig-hudson-string-build-parameter">
          <title>Adding a parameter to the build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-string-build-parameter.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>When the user starts a parameterized build job (parameterized
      build jobs are very often started manually), Jenkins will propose a page
      where the user can enter values for each of the build job's parameters
      (see <xref linkend="fig-hudson-enter-string-parameter" />).</para>

      <para><figure id="fig-hudson-enter-string-parameter">
          <title>Adding a parameter to the build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-enter-string-parameter.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Adapting your builds to work with parameterized build
      scripts</title>

      <para>Once you have added a parameter, you need to configure your build
      scripts to use it. Choosing the parameter name wellis important here, as
      this is also the name of the variable that Jenkins will pass through as
      an environment variable when it runs the build job. To illustrate this,
      consider the very basic build job configuration in <xref
      linkend="fig-hudson-parameterized-shell" />, where we are simply echoing
      the build parameter back out to the console. Note that, to make the
      environment variables more portable across operating systems, it is good
      practice to put them all in upper case.</para>

      <para><figure id="fig-hudson-parameterized-shell">
          <title>Demonstrating a build parameter</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-parameterized-shell.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>When we run this, we would get a console output along the
      following lines:<screen>Started by user anonymous
Building on master
[workspace] $ /bin/sh -xe /var/folders/y+/y+a+wZ-jG6WKHEm9KwnSvE+++TI/-Tmp-/hudson5862957776458050998.sh
<command>+ echo Version=1.2.3</command>
<command>Version=1.2.3</command>
Notifying upstream projects of job completion
Finished: SUCCESS</screen></para>

      <para>You can also use these environment variables from within your
      build scripts. For example, in an Ant or Maven build, you can use the
      special <command>env</command> property to access the current
      environment variables:</para>

      <para><programlisting>&lt;target name="printversion"&gt;
  &lt;property environment="env" /&gt;
  &lt;echo message="${env.VERSION}"/&gt;
&lt;/target&gt;</programlisting>Another option is to pass the parameter into
      the build script as a property value. The following is a more involved
      example from a Maven POM file. In this example, Maven is configured to
      deploy a specific WAR file. We provide the version of the WAR file to be
      deployed in the <command>target.version</command> property, which is
      used in the dependency declaration, as shown below:</para>

      <para><programlisting>  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.wakaleo.gameoflife&lt;/groupId&gt;
      &lt;artifactId&gt;gameoflife-web&lt;/artifactId&gt;
      &lt;type&gt;war&lt;/type&gt;
      &lt;version&gt;<command>${target.version}</command>&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;properties&gt;
    <command>&lt;target.version&gt;RELEASE&lt;/target.version&gt;</command>
    ...
  &lt;/properties&gt;</programlisting></para>

      <para>When we invoke Maven, we pass in the parameter as one of the build
      properties (see <xref linkend="fig-hudson-inject-parameter-maven" />).
      We can then use a tool like Cargo to do the actual deployment - Maven
      will download the requested version of the WAR file from the local
      Enterprise Repository Manager, and deploy it to an application
      server.</para>

      <para><figure id="fig-hudson-inject-parameter-maven">
          <title>Adding a parameter to a Maven build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-inject-parameter-maven.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>That, in a nutshell, is how you can integrate build job
      parameters into your build. In addition to plain old String parameters,
      however, there are a few more sophisticated parameter types, that we
      will look at in the following paragraphs (see <xref
      linkend="fig-hudson-build-parameter-types" />).</para>
    </sect2>

    <sect2>
      <title>More advanced parameter types</title>

      <para><figure id="fig-hudson-build-parameter-types">
          <title>Many different types of parameters are available</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-parameter-types.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para><command>Password Parameters</command> are, as you would expect,
      very similar to String parameters, except that they are displayed as a
      password field.</para>

      <para>There are many cases where you which to present a limited set of
      parameter options. In a deployment build, you might want to let the user
      choose one of a number of target servers. Or you may want to present a
      list of supported browsers for a suite of acceptance tests.
      <command>Choice Parameters</command> let you define a set of values that
      will be displayed as a drop-down list (see <xref
      linkend="fig-hudson-build-parameter-choice" />). You need to provide a
      list of possible values, one per line, starting with the default
      value.</para>

      <para><figure id="fig-hudson-build-parameter-choice">
          <title>Configuring a Choice parameter</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-parameter-choice.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure><command>Boolean parameters</command> are, as you would
      expect, parameters that take a value of <command>true</command> or
      <command>false</command>. They are presented as check boxes.</para>

      <para>Two more exotic parameter types, which behave a little differently
      to the others, are <command>Run Parameters</command> and <command>File
      Parameters</command>.</para>

      <para><command>Run Parameters</command> let you select a particular run
      (or build) of a given build job (see <xref
      linkend="fig-hudson-build-parameter-run-param" />). The user picks from
      a list of build run numbers. The URL of the corresponding build run is
      stored in the specified parameter.</para>

      <para><figure id="fig-hudson-build-parameter-run-param">
          <title>Configuring a Run parameter</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-parameter-run-param.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>The URL (which will look something like
      <uri>http://hudson.myorg.com/job/game-of-life/197/</uri>) can be used to
      obtain information or artifacts from that build run. For example, you
      could obtain the JAR or WAR file archived in a previous build and run
      further tests with this particular binary in a separate build job. For
      example, to access the WAR file of a previous build in a multi-module
      Maven project, the URL would look something like this:<programlisting>http://hudson.myorg.com/job/game-of-life/197/artifact/gameoflife-web/target/gameoflife.war</programlisting></para>

      <para>So, using the parameter configured in <xref
      linkend="fig-hudson-build-parameter-run-param" />, you could access this
      WAR file using the following expression:<programlisting>${RELEASE_BUILD}gameoflife-web/target/gameoflife.war</programlisting></para>

      <para><command>File Parameters</command> let you upload a file into the
      build job workspace, so that it can then be used by the build script
      (see <xref linkend="fig-hudson-build-parameter-file" />). Jenkins will
      store the file into the specified location in the project workspace,
      where you can access it in your build scripts. You can use the
      <command>WORKSPACE</command> variable to refer to the current Jenkins
      workspace directory, so you could manipulate the file uploaded in <xref
      linkend="fig-hudson-build-parameter-file" /> by using the expression
      <command>${WORKSPACE}/deploy/app.war</command>.</para>

      <para><figure id="fig-hudson-build-parameter-file">
          <title>Configuring a File parameter</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-parameter-file.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Starting a parameterized build job remotely</title>

      <para>You can also start a parameterized build job remotely, by invoking
      the URL of the build job. The typical form of a parameterized build job
      URL is illustrated here:<programlisting>http://hudson.acme.org/job/myjob/buildWithParameters?PARAMETER=Value</programlisting></para>

      <para>So, in the example shown above, you could trigger a build like
      this: <programlisting>http://hudson.acme.org/job/parameterized-build/buildWithParameters?VERSION=1.2.3</programlisting></para>

      <para>When you use a URL to start a build job in this way, remember that
      the parameter names are case-sensitive, and that the values need to be
      escaped (just like any other HTTP parameter). And if you are using a Run
      parameter, you need to provide the name of the build job
      <emphasis>and</emphasis> the run number (e.g. game-of-life#197) and not
      just the run number.</para>
    </sect2>

    <sect2>
      <title>Parameterized build job history</title>

      <para>Finally, it can be very useful to know what parameters were used
      to run a particular parameterized build. For example, in an automated
      deployment build job, it is useful to know exactly what version was
      actually deployed. Fortunately, Jenkins stores these values in the build
      history (see <xref linkend="fig-hudson-build-parameter-history" />), so
      you can always go back and take a look.</para>

      <para><figure id="fig-hudson-build-parameter-history">
          <title>Jenkins stores what parameter values where used for each
          build</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-parameter-history.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Parameterized triggers</title>

    <para>When you trigger another build job from within a parameterized build
    job, it is often useful to be able to pass the parameters of the current
    build job to the new one. Suppose, for example, that you have an
    application that needs to be tested against several different databases.
    As we have seen, you could do this by setting up a parameterized build job
    that accepts the target database as a parameter. You may want to kick of a
    series of builds, all of which will need this parameter. </para>

    <para>If you try to do this using the conventional 'Build other projects'
    option in the Post-Build Actions section, it won't work. In fact, you
    can't trigger a parameterized build in this way.</para>

    <para>However, you can do this using the <command>Hudson Parameterized
    Trigger</command> plugin. This plugin lets you configure your build jobs
    to both trigger parameterized builds, and to pass arbitrary parameters to
    these builds.</para>

    <para>Once you install this plugin, you will find the option of
    'Triggering parameterized builds on other projects' in your build job
    configuration page (see <xref
    linkend="fig-hudson-build-parameters-trigger" />). This lets you start
    another build job in a number of ways. In particular, it lets you kick off
    a subsequent build job, passing the current parameters to this new build
    job, which is impossible to do with a normal triggered build. The best way
    to see how this works is through an example.</para>

    <para>In <xref linkend="fig-hudson-build-parameters-unit-test" /> we have
    an initial build job. This build job takes a single parameter, DATABASE,
    which specifies the database to be used for the tests. As we have seen,
    the user will be prompted to enter this value whenever the build is
    started.</para>

    <para><figure id="fig-hudson-build-parameters-unit-test">
        <title>Jenkins stores what parameter values where used for each
        build</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/hudson-build-parameters-unit-test.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Now suppose we want to trigger a second build job to run more
    comprehensive integration tests once this first build job has finished.
    However we need it to run the tests against the same database. We can do
    this by setting up a parameterized trigger to start this second build job
    (see <xref linkend="fig-hudson-build-parameters-trigger" />).</para>

    <para><figure id="fig-hudson-build-parameters-trigger">
        <title>Adding a parameterized trigger to a build job</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/hudson-build-parameters-trigger.png"
                       width="10.3in" />
          </imageobject>
        </mediaobject>
      </figure>In this case, we are simple passing through the current build
    parameters. This second build job will automatically be started after the
    first one, with the DATABASE parameter value provided by the user. You can
    also fine-tune the triggering policy, by telling Jenkins when the build
    should be triggered. Typically, you would only trigger a downstream build
    after your build has completed successfully, but with the Parameterized
    Trigger plugin you can also configure builds to be triggered even if the
    build is unstable, only when the build fails or ask for it to be triggered
    no matter what the outcome of the first build. You can even set up
    multiple triggers for the same build job.</para>

    <para>Naturally, the build job that you trigger must be a parameterized
    build job (as illustrated in <xref
    linkend="fig-hudson-build-parameters-unit-test" />), and you must pass
    through all of the parameters it requires.</para>

    <para><figure id="fig-hudson-build-parameters-unit-test">
        <title>The build job you trigger must also be a parameterized build
        job.</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/hudson-build-parameters-integration-tests.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>This feature actually has much broader applications than simply
    passing through the current build parameters. You can also trigger a
    parameterized build job with an arbitrary set of parameters, or use a
    combination of parameters that were passed to the current build, and your
    own additional ones. Or, if you have a lot of parameters, you can load
    them from a properties file. In <xref
    linkend="fig-hudson-build-parameters-deploy-trigger" />, we are passing
    both the current build parameters (the DATABASE variable in this case),
    and an additional parameter called TARGET_PLATFORM.</para>

    <para><figure id="fig-hudson-build-parameters-deploy-trigger">
        <title>The build job you trigger must also be a parameterized build
        job.</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/fig-hudson-build-parameters-deploy-trigger.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>
  </sect1>

  <sect1>
    <title>Multi-configuration build jobs</title>

    <para>Multi-configuration build jobs are an extremely powerful feature of
    Jenkins. A multi-configuration build job can be thought of as a
    parameterized build job that can be automatically run with all the
    possible combinations of parameters that it can accept. They are
    particularly useful for tests, where you can test your application using a
    single build job, but under a wide variety of conditions (browsers,
    databases, and so forth).</para>

    <para>To create a new multi-configuration build job, simply choose this
    option on the 'New Job' page (see <xref
    linkend="hudson-build-multi-configuration" />). </para>

    <para><figure id="fig-hudson-build-multi-configuration">
        <title>Creating a multi-configuration build job</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/hudson-build-multi-configuration.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>A multi-configuration build job is just like any other build
    job, but with one very important additional element: the
    <command>Configuration Matrix</command> (see <xref
    linkend="fig-hudson-build-multi-config" />). This is where you define the
    different configurations that will be used to run your builds.</para>

    <para><figure id="fig-hudson-build-multi-config">
        <title>Creating a multi-configuration build job</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/hudson-build-multi-config.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>You can define different axes of configuration options,
    including running the build job on different slaves or on different JDKs,
    or providing your own custom properties to the build. For example, in the
    build jobs discussed earlier, we might want to test our application for
    different databases and different operating systems. We could define one
    axis defining slave machines with different operating systems we wanted
    our build to run on, and another axis defining all the possible database
    values. Jenkins will then run the build job for each possible database and
    each possible operating system.</para>

    <para>Lets look at the types of axis you can define.</para>

    <para>hudson-build-multi-config</para>

    <para></para>

    <para>build-multi-config-slaves</para>

    <para></para>

    <para>- Custom axis - add your own variables</para>

    <para>- Running each configuration separately</para>

    <para>- Combination filter</para>

    <para>- Touchstone builds</para>

    <sect2>
      <title>Setting up a multi-configuration build</title>

      <para>To create a new multi-configuration build job, simply choose this
      option on the 'New Job' page (see <xref
      linkend="hudson-build-multi-configuration" />).</para>

      <para><figure id="fig-hudson-build-multi-configuration">
          <title>Creating a multi-configuration build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-multi-configuration.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>A multi-configuration build job is just like any other build
      job, but with one very important additional element: the
      <command>Configuration Matrix</command> (see <xref
      linkend="fig-hudson-build-multi-config" />). This is where you define
      the different configurations that will be used to run your
      builds.</para>

      <para><figure id="fig-hudson-build-multi-config">
          <title>Creating a multi-configuration build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-multi-config.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>You can define different axes of configuration options,
      including running the build job on different slaves or on different
      JDKs, or providing your own custom properties to the build. For example,
      in the build jobs discussed earlier, we might want to test our
      application for different databases and different operating systems. We
      could define one axis defining slave machines with different operating
      systems we wanted our build to run on, and another axis defining all the
      possible database values. Jenkins will then run the build job for each
      possible database and each possible operating system.</para>

      <para>Lets look at the types of axis you can define.</para>
    </sect2>

    <sect2>
      <title>Configuring a Slave axis</title>

      <para>The first option is to configure your build to run simultaneously
      on different slave machines. Now of course, the idea of having a set of
      slave machines is usually that you can run your build job on any of
      them. But there are cases where it makes sense to be a little more
      choosy. For example, you might want your tests to run on Windows, Mac OS
      X, and Linux. In this case, you create a new axis for your slave nodes,
      as shown in <xref linkend="fig-build-multi-config-slaves" />. You can
      choose the nodes you want to use in two ways: by label or by individual
      node. Using labels lets you identify categories of build nodes (for
      example, Windows machines), without tying the build to any one machine.
      This is a more flexible option, and makes it easier to expand your build
      capacity as required. Sometimes, however, you may really want to run a
      build on a specific machine. In this case, you can use the 'Individual
      nodes' option, and choose the machine in this list. We will discuss
      working with slave nodes and distributed builds in more detail in <xref
      linkend="chapter-distributed-builds" />.</para>

      <para><figure id="fig-build-multi-config-slaves">
          <title>Defining an axis of slave nodes</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/build-multi-config-slaves.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Configuring a JDK axis</title>

      <para>If you are deploying your application to a broad client base where
      you have limited control over the target environment, you may need to
      test your application using different versions of Java. In cases like
      this it is useful to be able to set up a JDK axis in a
      multi-configuration build. When you add a JDK axis, Jenkins will
      automatically propose the list of JDK versions that it knows about (see
      <xref linkend="???" />). If you need to use additional JDKs, just add
      them to your Jenkins configuration page.</para>

      <para><figure id="fig-hudson-build-multi-config-jdk">
          <title>Defining an axis of JDK versions</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-multi-config-jdk.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Custom axis</title>

      <para>The third type of axis lets you define different ways to run your
      build job, based on arbitrary variables that you define. For example,
      you might provide a list of databases you need to test against, or a
      list of browsers to use in your web tests. These are like parameters for
      a parameterized build job, except that you provide the complete list of
      possible values, and rather than prompting for you to enter a value,
      Jenkins will run the build with <emphasis>all</emphasis> of the values
      you provide (<xref
      linkend="fig-hudson-build-mulit-config-custom" />).</para>

      <para><figure id="fig-hudson-build-mulit-config-custom">
          <title>Defining a user-defined</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-mulit-config-custom.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Running a multi-configuration build</title>

      <para>Once you have set up the axes, you can run your
      multi-configuration build just like any other. However, Jenkins will
      treat each combination of variables as a separate build job, running
      them in parallel as much as possible. Hudson displays the aggregate
      results in a table, where all of the combinations are shown (see <xref
      linkend="fig-hudson-build-mulit-config-custom" />). If you click on any
      of the balls, Jenkins will take you to the detailed results for that
      particular build.</para>

      <para><figure id="fig-hudson-build-mulit-config-custom">
          <title>Defining a user-defined</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-multi-config-results.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Conclusion</title>

    <para>TODO</para>
  </sect1>
</chapter>
