<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="chapter-advanced-builds">
  <title>Advanced Builds</title>

  <sect1>
    <title>Introduction</title>

    <para><indexterm>
        <primary>Advanced builds</primary>
      </indexterm>In this chapter, we will look at some more advanced build
    job setups.</para>
  </sect1>

  <sect1>
    <title>Parameterized build jobs</title>

    <para>Parameterized builds are a powerful concept that enable you to add
    another dimension to your build jobs.</para>

    <para>The <command>Parameterized Build</command> plugin lets you configure
    parameters for your build job, that can be either entered by the user when
    the build job is triggered, or (as we will see later) from another build
    job.</para>

    <para>For example, you might have a deployment build job, where you want
    to choose the target environment in a drop-down list when you start the
    build job. Or you may want to specify the version of the application you
    want to deploy. Or, when running a build job involving web tests, you
    might want to specify the browser to run your Selenium or WebDriver tests
    in. You can even upload a file to be used by the build job.</para>

    <sect2>
      <title>Creating a parameterized build jobs</title>

      <para>You install the Parameterized Build plugin as usual, via the
      Plugin Manager screen. Once you have done this, configuring a
      parameterized build job is straight-forward. Just tick the 'This build
      is parameterized' option and click 'Add Parameter' to add a new build
      job parameter (see <xref linkend="fig-hudson-parameterized-build" />).
      You can add parameters to any sort of build, and you can add as many
      parameters as you want for a given build job.</para>

      <para><figure id="fig-hudson-parameterized-build">
          <title>Creating a parameterized build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-parameterized-build.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>To add a parameter to your build job, just pick the parameter type
      in the drop-down list. This will let you configure the details of your
      parameter (see <xref linkend="fig-hudson-string-build-parameter" />).
      You can choose from several different parameter types, such as Strings,
      Booleans, and drop-down lists. Depending on the type you choose, you
      will have to enter slightly different configuration values, but the
      basic process is identical. All parameter types, with the exception of
      the File parameter (see below), have a name and a description, and most
      often a default value.</para>

      <para>In <xref linkend="fig-hudson-enter-string-parameter" />, for
      example, we are adding a parameter called <command>version</command> to
      a deployment build job. The default value ("RELEASE") will be initially
      displayed when Jenkins prompts the user for this parameter, so if the
      user doesn't change anything, this value will be used.</para>

      <para><figure id="fig-hudson-string-build-parameter">
          <title>Adding a parameter to the build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-string-build-parameter.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>When the user starts a parameterized build job (parameterized
      build jobs are very often started manually), Jenkins will propose a page
      where the user can enter values for each of the build job's parameters
      (see <xref linkend="fig-hudson-enter-string-parameter" />).</para>

      <para><figure id="fig-hudson-enter-string-parameter">
          <title>Adding a parameter to the build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-enter-string-parameter.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Adapting your builds to work with parameterized build
      scripts</title>

      <para>Once you have added a parameter, you need to configure your build
      scripts to use it. Choosing the parameter name wellis important here, as
      this is also the name of the variable that Jenkins will pass through as
      an environment variable when it runs the build job. To illustrate this,
      consider the very basic build job configuration in <xref
      linkend="fig-hudson-parameterized-shell" />, where we are simply echoing
      the build parameter back out to the console. Note that, to make the
      environment variables more portable across operating systems, it is good
      practice to put them all in upper case.</para>

      <para><figure id="fig-hudson-parameterized-shell">
          <title>Demonstrating a build parameter</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-parameterized-shell.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>When we run this, we would get a console output along the
      following lines:<screen>Started by user anonymous
Building on master
[workspace] $ /bin/sh -xe /var/folders/y+/y+a+wZ-jG6WKHEm9KwnSvE+++TI/-Tmp-/hudson5862957776458050998.sh
<command>+ echo Version=1.2.3</command>
<command>Version=1.2.3</command>
Notifying upstream projects of job completion
Finished: SUCCESS</screen></para>

      <para>You can also use these environment variables from within your
      build scripts. For example, in an Ant or Maven build, you can use the
      special <command>env</command> property to access the current
      environment variables:</para>

      <para><programlisting>&lt;target name="printversion"&gt;
  &lt;property environment="env" /&gt;
  &lt;echo message="${env.VERSION}"/&gt;
&lt;/target&gt;</programlisting>Another option is to pass the parameter into
      the build script as a property value. The following is a more involved
      example from a Maven POM file. In this example, Maven is configured to
      deploy a specific WAR file. We provide the version of the WAR file to be
      deployed in the <command>target.version</command> property, which is
      used in the dependency declaration, as shown below:</para>

      <para><programlisting>  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.wakaleo.gameoflife&lt;/groupId&gt;
      &lt;artifactId&gt;gameoflife-web&lt;/artifactId&gt;
      &lt;type&gt;war&lt;/type&gt;
      &lt;version&gt;<command>${target.version}</command>&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;properties&gt;
    <command>&lt;target.version&gt;RELEASE&lt;/target.version&gt;</command>
    ...
  &lt;/properties&gt;</programlisting></para>

      <para>When we invoke Maven, we pass in the parameter as one of the build
      properties (see <xref linkend="fig-hudson-inject-parameter-maven" />).
      We can then use a tool like Cargo to do the actual deployment - Maven
      will download the requested version of the WAR file from the local
      Enterprise Repository Manager, and deploy it to an application
      server.</para>

      <para><figure id="fig-hudson-inject-parameter-maven">
          <title>Adding a parameter to a Maven build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-inject-parameter-maven.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>That, in a nutshell, is how you can integrate build job
      parameters into your build. In addition to plain old String parameters,
      however, there are a few more sophisticated parameter types, that we
      will look at in the following paragraphs (see <xref
      linkend="fig-hudson-build-parameter-types" />).</para>
    </sect2>

    <sect2>
      <title>More advanced parameter types</title>

      <para><figure id="fig-hudson-build-parameter-types">
          <title>Many different types of parameters are available</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-parameter-types.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para><command>Password Parameters</command> are, as you would expect,
      very similar to String parameters, except that they are displayed as a
      password field.</para>

      <para>There are many cases where you which to present a limited set of
      parameter options. In a deployment build, you might want to let the user
      choose one of a number of target servers. Or you may want to present a
      list of supported browsers for a suite of acceptance tests.
      <command>Choice Parameters</command> let you define a set of values that
      will be displayed as a drop-down list (see <xref
      linkend="fig-hudson-build-parameter-choice" />). You need to provide a
      list of possible values, one per line, starting with the default
      value.</para>

      <para><figure id="fig-hudson-build-parameter-choice">
          <title>Configuring a Choice parameter</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-parameter-choice.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure><command>Boolean parameters</command> are, as you would
      expect, parameters that take a value of <command>true</command> or
      <command>false</command>. They are presented as check boxes.</para>

      <para>Two more exotic parameter types, which behave a little differently
      to the others, are <command>Run Parameters</command> and <command>File
      Parameters</command>.</para>

      <para><command>Run Parameters</command> let you select a particular run
      (or build) of a given build job (see <xref
      linkend="fig-hudson-build-parameter-run-param" />). The user picks from
      a list of build run numbers. The URL of the corresponding build run is
      stored in the specified parameter.</para>

      <para><figure id="fig-hudson-build-parameter-run-param">
          <title>Configuring a Run parameter</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-parameter-run-param.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>The URL (which will look something like
      <uri>http://hudson.myorg.com/job/game-of-life/197/</uri>) can be used to
      obtain information or artifacts from that build run. For example, you
      could obtain the JAR or WAR file archived in a previous build and run
      further tests with this particular binary in a separate build job. For
      example, to access the WAR file of a previous build in a multi-module
      Maven project, the URL would look something like this:<programlisting>http://hudson.myorg.com/job/game-of-life/197/artifact/gameoflife-web/target/gameoflife.war</programlisting></para>

      <para>So, using the parameter configured in <xref
      linkend="fig-hudson-build-parameter-run-param" />, you could access this
      WAR file using the following expression:<programlisting>${RELEASE_BUILD}gameoflife-web/target/gameoflife.war</programlisting></para>

      <para><command>File Parameters</command> let you upload a file into the
      build job workspace, so that it can then be used by the build script
      (see <xref linkend="fig-hudson-build-parameter-file" />). Jenkins will
      store the file into the specified location in the project workspace,
      where you can access it in your build scripts. You can use the
      <command>WORKSPACE</command> variable to refer to the current Jenkins
      workspace directory, so you could manipulate the file uploaded in <xref
      linkend="fig-hudson-build-parameter-file" /> by using the expression
      <command>${WORKSPACE}/deploy/app.war</command>.</para>

      <para><figure id="fig-hudson-build-parameter-file">
          <title>Configuring a File parameter</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-parameter-file.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Starting a parameterized build job remotely</title>

      <para>You can also start a parameterized build job remotely, by invoking
      the URL of the build job. The typical form of a parameterized build job
      URL is illustrated here:<programlisting>http://hudson.acme.org/job/myjob/buildWithParameters?PARAMETER=Value</programlisting></para>

      <para>So, in the example shown above, you could trigger a build like
      this: <programlisting>http://hudson.acme.org/job/parameterized-build/buildWithParameters?VERSION=1.2.3</programlisting></para>

      <para>When you use a URL to start a build job in this way, remember that
      the parameter names are case-sensitive, and that the values need to be
      escaped (just like any other HTTP parameter). And if you are using a Run
      parameter, you need to provide the name of the build job
      <emphasis>and</emphasis> the run number (e.g. game-of-life#197) and not
      just the run number.</para>
    </sect2>

    <sect2>
      <title>Parameterized build job history</title>

      <para>Finally, it can be very useful to know what parameters were used
      to run a particular parameterized build. For example, in an automated
      deployment build job, it is useful to know exactly what version was
      actually deployed. Fortunately, Jenkins stores these values in the build
      history (see <xref linkend="fig-hudson-build-parameter-history" />), so
      you can always go back and take a look.</para>

      <para><figure id="fig-hudson-build-parameter-history">
          <title>Jenkins stores what parameter values where used for each
          build</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-parameter-history.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Parameterized triggers</title>

    <para>When you trigger another build job from within a parameterized build
    job, it is often useful to be able to pass the parameters of the current
    build job to the new one. Suppose, for example, that you have an
    application that needs to be tested against several different databases.
    As we have seen, you could do this by setting up a parameterized build job
    that accepts the target database as a parameter. You may want to kick of a
    series of builds, all of which will need this parameter.</para>

    <para>If you try to do this using the conventional 'Build other projects'
    option in the Post-Build Actions section, it won't work. In fact, you
    can't trigger a parameterized build in this way.</para>

    <para>However, you can do this using the <command>Hudson Parameterized
    Trigger</command> plugin. This plugin lets you configure your build jobs
    to both trigger parameterized builds, and to pass arbitrary parameters to
    these builds.</para>

    <para>Once you install this plugin, you will find the option of
    'Triggering parameterized builds on other projects' in your build job
    configuration page (see <xref
    linkend="fig-hudson-build-parameters-trigger" />). This lets you start
    another build job in a number of ways. In particular, it lets you kick off
    a subsequent build job, passing the current parameters to this new build
    job, which is impossible to do with a normal triggered build. The best way
    to see how this works is through an example.</para>

    <para>In <xref linkend="fig-hudson-build-parameters-unit-test" /> we have
    an initial build job. This build job takes a single parameter, DATABASE,
    which specifies the database to be used for the tests. As we have seen,
    the user will be prompted to enter this value whenever the build is
    started.</para>

    <para><figure id="fig-hudson-build-parameters-unit-test">
        <title>Jenkins stores what parameter values where used for each
        build</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/hudson-build-parameters-unit-test.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Now suppose we want to trigger a second build job to run more
    comprehensive integration tests once this first build job has finished.
    However we need it to run the tests against the same database. We can do
    this by setting up a parameterized trigger to start this second build job
    (see <xref linkend="fig-hudson-build-parameters-trigger" />).</para>

    <para><figure id="fig-hudson-build-parameters-trigger">
        <title>Adding a parameterized trigger to a build job</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/hudson-build-parameters-trigger.png"
                       width="10.3in" />
          </imageobject>
        </mediaobject>
      </figure>In this case, we are simple passing through the current build
    parameters. This second build job will automatically be started after the
    first one, with the DATABASE parameter value provided by the user. You can
    also fine-tune the triggering policy, by telling Jenkins when the build
    should be triggered. Typically, you would only trigger a downstream build
    after your build has completed successfully, but with the Parameterized
    Trigger plugin you can also configure builds to be triggered even if the
    build is unstable, only when the build fails or ask for it to be triggered
    no matter what the outcome of the first build. You can even set up
    multiple triggers for the same build job.</para>

    <para>Naturally, the build job that you trigger must be a parameterized
    build job (as illustrated in <xref
    linkend="fig-hudson-build-parameters-unit-test" />), and you must pass
    through all of the parameters it requires.</para>

    <para><figure id="fig-hudson-build-parameters-unit-test">
        <title>The build job you trigger must also be a parameterized build
        job.</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/hudson-build-parameters-integration-tests.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>This feature actually has much broader applications than simply
    passing through the current build parameters. You can also trigger a
    parameterized build job with an arbitrary set of parameters, or use a
    combination of parameters that were passed to the current build, and your
    own additional ones. Or, if you have a lot of parameters, you can load
    them from a properties file. In <xref
    linkend="fig-hudson-build-parameters-deploy-trigger" />, we are passing
    both the current build parameters (the DATABASE variable in this case),
    and an additional parameter called TARGET_PLATFORM.</para>

    <para><figure id="fig-hudson-build-parameters-deploy-trigger">
        <title>The build job you trigger must also be a parameterized build
        job.</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/fig-hudson-build-parameters-deploy-trigger.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>
  </sect1>

  <sect1 id="sect-multi-configuration-build-jobs">
    <title>Multi-configuration build jobs</title>

    <para>Multi-configuration build jobs are an extremely powerful feature of
    Jenkins. A multi-configuration build job can be thought of as a
    parameterized build job that can be automatically run with all the
    possible combinations of parameters that it can accept. They are
    particularly useful for tests, where you can test your application using a
    single build job, but under a wide variety of conditions (browsers,
    databases, and so forth).</para>

    <para>To create a new multi-configuration build job, simply choose this
    option on the 'New Job' page (see <xref
    linkend="hudson-build-multi-configuration" />).</para>

    <para><figure id="fig-hudson-build-multi-configuration">
        <title>Creating a multi-configuration build job</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/hudson-build-multi-configuration.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>A multi-configuration build job is just like any other build
    job, but with one very important additional element: the
    <command>Configuration Matrix</command> (see <xref
    linkend="fig-hudson-build-multi-config" />). This is where you define the
    different configurations that will be used to run your builds.</para>

    <para><figure id="fig-hudson-build-multi-config">
        <title>Creating a multi-configuration build job</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="figs/web/hudson-build-multi-config.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>You can define different axes of configuration options,
    including running the build job on different slaves or on different JDKs,
    or providing your own custom properties to the build. For example, in the
    build jobs discussed earlier, we might want to test our application for
    different databases and different operating systems. We could define one
    axis defining slave machines with different operating systems we wanted
    our build to run on, and another axis defining all the possible database
    values. Jenkins will then run the build job for each possible database and
    each possible operating system.</para>

    <sect2>
      <title>Setting up a multi-configuration build</title>

      <para>To create a new multi-configuration build job, simply choose this
      option on the 'New Job' page (see <xref
      linkend="hudson-build-multi-configuration" />).</para>

      <para><figure id="fig-hudson-build-multi-configuration">
          <title>Creating a multi-configuration build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-multi-configuration.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>A multi-configuration build job is just like any other build
      job, but with one very important additional element: the
      <command>Configuration Matrix</command> (see <xref
      linkend="fig-hudson-build-multi-config" />). This is where you define
      the different configurations that will be used to run your
      builds.</para>

      <para><figure id="fig-hudson-build-multi-config">
          <title>Adding an axis to a multi-configuration build</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-multi-config.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>You can define different axes of configuration options,
      including running the build job on different slaves or on different
      JDKs, or providing your own custom properties to the build. For example,
      in the build jobs discussed earlier, we might want to test our
      application for different databases and different operating systems. We
      could define one axis defining slave machines with different operating
      systems we wanted our build to run on, and another axis defining all the
      possible database values. Jenkins will then run the build job for each
      possible database and each possible operating system.</para>

      <para>Lets look at the types of axis you can define.</para>
    </sect2>

    <sect2>
      <title>Configuring a Slave axis</title>

      <para>The first option is to configure your build to run simultaneously
      on different slave machines. Now of course, the idea of having a set of
      slave machines is usually that you can run your build job on any of
      them. But there are cases where it makes sense to be a little more
      choosy. For example, you might want your tests to run on Windows, Mac OS
      X, and Linux. In this case, you create a new axis for your slave nodes,
      as shown in <xref linkend="fig-build-multi-config-slaves" />. You can
      choose the nodes you want to use in two ways: by label or by individual
      node. Using labels lets you identify categories of build nodes (for
      example, Windows machines), without tying the build to any one machine.
      This is a more flexible option, and makes it easier to expand your build
      capacity as required. Sometimes, however, you may really want to run a
      build on a specific machine. In this case, you can use the 'Individual
      nodes' option, and choose the machine in this list. We will discuss
      working with slave nodes and distributed builds in more detail in <xref
      linkend="chapter-distributed-builds" />.</para>

      <para><figure id="fig-build-multi-config-slaves">
          <title>Defining an axis of slave nodes</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/build-multi-config-slaves.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Configuring a JDK axis</title>

      <para>If you are deploying your application to a broad client base where
      you have limited control over the target environment, you may need to
      test your application using different versions of Java. In cases like
      this it is useful to be able to set up a JDK axis in a
      multi-configuration build. When you add a JDK axis, Jenkins will
      automatically propose the list of JDK versions that it knows about (see
      <xref linkend="???" />). If you need to use additional JDKs, just add
      them to your Jenkins configuration page.</para>

      <para><figure id="fig-hudson-build-multi-config-jdk">
          <title>Defining an axis of JDK versions</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-multi-config-jdk.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Custom axis</title>

      <para>The third type of axis lets you define different ways to run your
      build job, based on arbitrary variables that you define. For example,
      you might provide a list of databases you need to test against, or a
      list of browsers to use in your web tests. These are like parameters for
      a parameterized build job, except that you provide the complete list of
      possible values, and rather than prompting for you to enter a value,
      Jenkins will run the build with <emphasis>all</emphasis> of the values
      you provide (<xref
      linkend="fig-hudson-build-mulit-config-custom" />).</para>

      <para><figure id="fig-hudson-build-mulit-config-custom">
          <title>Defining a user-defined axis</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-mulit-config-custom.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Running a multi-configuration build</title>

      <para>Once you have set up the axes, you can run your
      multi-configuration build just like any other. However, Jenkins will
      treat each combination of variables as a separate build job. Hudson
      displays the aggregate results in a table, where all of the combinations
      are shown (see <xref linkend="fig-hudson-build-mulit-config-custom" />).
      If you click on any of the balls, Jenkins will take you to the detailed
      results for that particular build.</para>

      <para><figure id="fig-hudson-build-mulit-config-custom">
          <title>Multi-configuration build results</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-multi-config-results.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>By default, Jenkins will run the build jobs in parallel.
      However there are some cases where this is not a good idea. For example,
      many Java web applications use Selenium or WebDriver tests running
      against a local instance of Jetty that is automatically started by the
      build job. Build scripts like this need to be specially configured to be
      able to run in parallel on the same machine, to avoid port conflicts.
      Concurrent database access during tests can be another source of
      problems if concurrency is not designed into the tests. If your builds
      are not designed to run in parallel, you can force Jenkins to run the
      tests sequentially by ticking the 'Run each configuration sequentially'
      checkbox at the bottom of the <command>Configuration Matrix</command>
      section.</para>

      <para>By default, Jenkins will run all possible combinations of the
      different axes. So, in the above example, we have three environments,
      two JDKs, and four databases. This results in a total of 24 builds.
      However, in some cases, it may not make sense (or be possible) to run
      certain combinations. For example, suppose you have a build job that
      runs automated web tests. If one axis contains the web browsers to be
      tested (Firefox, Internet Explorer, Chrome,...) and another the
      Operating Systems (Linux, Windows, Mac OS), it would make little sense
      to run Internet Explorer with Linux or Mac OS.</para>

      <para>The <command>Combination Filter</command> option lets you set up
      rules about which combinations of variables are valid. This field is a
      Groovy boolean expression that uses the names of the variables you
      defined for each axis. The expression must evaluate to true for the
      build to execute. For example, suppose you have a build job running web
      tests in different browsers on different operating systems (see <xref
      linkend="fig-hudson-build-multi-config-filters" />). The tests need to
      run Firefox, Internet Explorer and Chrome, on Windows, Mac OS X and
      Linux. However Internet Explorer only runs on Windows, and Chrome does
      not run on Linux.</para>

      <para><figure id="fig-hudson-build-multi-config-filters">
          <title>Setting up a combination filter</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-multi-config-filters.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>To set this up with a Combination Filter, we could use an
      expression like the following:</para>

      <programlisting>(browser=="firefox") 
|| (browser=="iexplorer" &amp;&amp; os=="windows") 
|| (browser=="chrome" &amp;&amp; os != "linux") </programlisting>

      <para>This would result in only the correct browser/operating system
      combinations being executed (see <xref
      linkend="fig-hudson-multi-config-filter-result" />). Executed builds are
      displayed in the usual colors, whereas skipped builds are shown in
      grey.</para>

      <para><figure id="fig-hudson-multi-config-filter-result">
          <title>Build results using a combination filter</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-multi-config-filter-result.png "
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>Another reason to use a build filter is that there are simply
      too many valid combinations to run in a reasonable time. In this case,
      the best solution may be to upscale your build server. The second-best
      solution, on the other hand, might be to only run a sub-set of the
      combinations, possibly running the full set of combinations on a nightly
      basis. You can do this by using the special <code>index</code> variable.
      If you include the expression <code>(index%2 == 0)</code>, for example,
      will ensure that only one build job in two is actually executed.</para>

      <para>You may also want certain builds to be executed before the others,
      as a sanity check. For example, you might want to run the default (and,
      theoretically, the most reliable) configuration for your application
      first, before continuing on to more exotic combinations. To do this, you
      can use the 'Execute touchstone builds first' option. Here, you enter a
      filter value (like the one seen above) to define the first build or
      builds to be executed. You can also specify if the build should proceed
      only if these builds are successful, or even if they are unsuccessful.
      Once these builds have completed as expected, Jenkins will proceed with
      the other combinations.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Organizing your build jobs</title>

    <para>Depending on the size of your team and organization, the number of
    build jobs that your Jenkins server will host can vary a great deal. As
    the number of build jobs grows, the Jenkins dashboard can become
    cluttered. In this section we will look at how to use views to group and
    organize your build jobs.</para>

    <sect2>
      <title>Views</title>

      <para>Views are the simplest way to organize your build jobs. A view
      lets you display a subset of the build jobs on your server, either by
      picking them individually, or by defining a regular expression. Views
      are often used on larger servers to group build jobs by project,
      application, or team.</para>

      <para>Views are easy to set up. Just click on the '+' icon at the top of
      the page, and choose a name for your new view (see <xref
      linkend="fig-hudson-view-new" />). The name you choose will appear in
      the tabs on the Jenkins home page, and in the URLs accessing the build
      job pages - for this reason, I generally avoid spaces.</para>

      <para>You also need to choose the type of view you want to create. By
      default, only the standard 'list' view is available, but many more are
      available through additional plugins, as we will see further on.</para>

      <para><figure id="fig-hudson-view-new">
          <title>Creating a new view</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-view-new.png" width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Once you have created your new view, you need to tell Jenkins what
      build jobs will figure in it, and what other associated information will
      be displayed (see <xref linkend="fig-hudson-view-new-details" />). The
      simplest way to choose the jobs to be displayed one by one, simply by
      ticking them in the Jobs list.</para>

      <para><figure id="fig-hudson-view-new-details">
          <title>Creating a new view</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-view-new-details.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>A more robust approach, however, is to use a regular expression to
      define the names of the build jobs to be displayed (see <xref
      linkend="fig-build-view-regex" />). For example, the expression
      <code>game-of-life.*</code> will display all of the build jobs whose
      name starts with "game-of-life". If the names of your build jobs follow
      some well-defined convention (as they should), this is an excellent way
      to make maintaining your views a lot easier.</para>

      <para>Another useful option, if your build server hosts a large number
      of build jobs, is to filter the build queue and build executors so that
      only the activity of build jobs displayed in your build will appear in
      the build queue or executors, while you are in this view. This avoids
      unnecessary pollution about irrelevant builds whilst you are in this
      view, though you can always get a full picture of all of the build jobs
      on the dashboard page. You can configure this towards the two check
      boxes at the top of the build configuration page.</para>

      <para><figure id="fig-build-view-regex">
          <title>Using a regular expression to define the jobs to be
          displayed</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/build-view-regex.png" width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>By default, the view will contain the same columns as appear on
      the main dashboard. This is usually fine, but you do have the option of
      adding, deleting or changing the order of the columns that appear in the
      view (see <xref linkend="fig-hudson-view-add-column" />).</para>

      <para><figure id="fig-hudson-view-add-column">
          <title>Using a regular expression to define the jobs to be
          displayed</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-view-add-column.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>Once you are happy with the configuration of your view, save
      your changes. Your view will now appear as an additional tab on the
      dashboard, displaying only the jobs you specified (see <xref
      linkend="fig-hudson-display-view" />). When you are in a view, Jenkins
      will also display menu options allowing you to edit or delete the
      view.</para>

      <para><figure id="fig-hudson-view-add-column">
          <title>The final view</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-view-display.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Nested Views</title>

      <para>Most Jenkins instances host between a dozen and a hundred or so
      build jobs. However some host a great deal more than that, and once the
      number of build jobs gets beyond a few dozen, things start to become
      very crowded on the Jenkins home page.</para>

      <para>One solution to this issue would be to regroup your build jobs
      into folders. Jenkins does not support this feature out of the box.
      However, the <command>Nested View</command> plugin does let you create
      folders of build jobs. Once you install this plugin, you can choose the
      'Nested View' option when you create a new view (see <xref
      linkend="fig-hudson-nested-view-new" />).</para>

      <para><figure id="fig-hudson-nested-view-new">
          <title>Creating a new Nested View</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-nested-view-new.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>This doesn't do much in itself. After a page where you enter
      a description of your build and the filtering options we saw in the
      standard view, it will essentially create an empty view (see <xref
      linkend="fig-hudson-nested-view-empty" />). From here, you can add new
      view that will be nested inside this one by clicking on the 'New View'
      menu option.</para>

      <para><figure id="fig-hudson-nested-view-empty">
          <title>Creating a new Nested View</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-nested-view-empty.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>You can add any view you want to a nested view, even another
      nested view. The views you define are displayed as folders on the view
      home page (see <xref
      linkend="fig-hudson-nested-view-summary" />).</para>

      <para><figure id="fig-hudson-nested-view-summary">
          <title>Nested views in action</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-nested-view-summary.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Coordinating your builds</title>

    <para>Triggering downstream build jobs is easy enough. However, when
    setting up larger and more complicated build job setups, you sometimes
    would like builds to be able to run concurrently, or possibly wait for
    certain build jobs to finish before proceeding. In this section, we will
    look at techniques and plugins that can help you do this.</para>

    <sect2>
      <title>Parallel builds in Jenkins</title>

      <para>Jenkins has built-in support for parallel builds - when a build
      job starts, Jenkins will assign it to the first available build node, so
      you can potentially have as many parallel builds running as you have
      build nodes available.</para>

      <para>If you need to run slight variations of the same build job in
      parallel, multi-configuration build jobs (see <xref
      linkend="sect-multi-configuration-build-jobs" />) are an excellent
      option. This can come in handy as a way of accelerating your build
      process. A typical application of multi-configuration build jobs in this
      context is to run integration tests in parallel. One strategy is to set
      up an integration test build job that can be run in different ways to
      execute different subsets of the integration tests. You could define
      separate Maven profiles, for example, or configure your build to use a
      command-line parameter to decide which tests to run. Once you have set
      up your build script in this way, it is easy to configure a
      multi-configuration build job to run the subsets of your integration
      tests in parallel.</para>

      <para>You can also get Hudson to trigger several downstream builds in
      parallel, simply by listing them all in the 'Build other projects' field
      (see <xref linkend="hudson-build-other-projects" />). The subsequent
      build jobs will be executed in parallel as much as possible. However, as
      we will see further on, this may not always be exactly what you
      need.</para>

      <para><figure id="fig-hudson-build-other-projects">
          <title>Triggering several other builds after a build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-other-projects.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Dependency Graphs</title>

      <para>Before we investigate the finer points of parallel builds, it is
      useful to be able to visualise the relationships between your build
      jobs. The Dependency Graph View plugin analyzes your build jobs and
      displays a graph describing the upstream and downstream connections
      between your jobs. This plugin uses graphviz (<ulink
      url="???">http://www.graphviz.org/</ulink>), which you will need to
      install on your server if you don't already have it.</para>

      <para>This plugin added a Dependency Graph icon in the main menu, which
      displays the a graph showing the relationships between the all the build
      jobs in your project (at the dashboard level), or all of the build jobs
      related to the current build job (when you are inside a particular
      project (see <xref linkend="fig-hudson-dependency-graph" />). What's
      more, if you click on a build job in the graph, Jenkins will take you
      directly to the project page of that build job.</para>

      <para><figure id="fig-hudson-dependency-graph">
          <title>Triggering several other builds after a build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-dependency-graph.png"
                         width="12.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Joins</title>

      <para>When setting up more complicated build pipelines, you frequently
      come across situations where a build job cannot proceed until a number
      of other build jobs have been completed, but that these upstream build
      jobs do not need to be executed sequentially. For example, in <xref
      linkend="fig-hudson-dependency-graph" />, imagine that the
      <command>phoenix-deploy-to-uat</command> build job actually requires
      three jobs to succeed before it can be executed:
      <command>phoenix-compatibility-tests</command>,
      <command>phoenix-load-tests</command> and
      <command>phoenix-performance-tests</command>.</para>

      <para>We can set this up by using the <command>Joins Plugin</command>,
      which you will need to install in the usual way via the Update center.
      Once installed, you configure a join in the build job that initiates the
      join process (in our example, this would be
      <command>phoenix-web-tests</command>). In our example, we need to modify
      the <command>phoenix-web-tests</command> build job so that it triggers
      the <command>phoenix-compatibility-tests</command>,
      <command>phoenix-load-tests</command> and
      <command>phoenix-performance-tests</command> first, and then, if these
      three succeed, the <command>phoenix-deploy-to-uat</command> build
      job.</para>

      <para>We do this by simply configuring the <command>Join
      Trigger</command> field with the name of the
      <command>phoenix-deploy-to-uat</command> build job (see <xref
      linkend="fig-hudson-build-join" />). The <command>Build other
      Projects</command> field is not modified, and still lists the build jobs
      to be triggered immediately after the current one. The <command>Join
      Trigger</command> field contains the build jobs to be built once all of
      the immediate downstream build jobs have finished.</para>

      <para><figure id="fig-hudson-build-join">
          <title>Configuring a join in the phoenix-web-tests build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/hudson-build-join.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>As a result, you no longer need the original build trigger
      for the final build job, as it is now redundant.</para>

      <para>This new flow shows up nicely in the dependency graphs as
      illustrated in <xref linkend="build-dependency-graph-join" />.</para>

      <para><figure id="fig-build-dependency-graph-join">
          <title>Configuring a join in the phoenix-web-tests build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/build-dependency-graph-join.png"
                         width="9.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Locks and Latches</title>

      <para>In other situations, you might be able to run a series of builds
      in parallel to some degree, but certain build jobs cannot be run in
      parallel because they access concurrent resources. Of course,
      well-designed build jobs should strive to be as independent as possible,
      but sometimes this can be difficult, especially with legacy projects.
      For example, different build jobs may need to access the same test
      database or files on the hard disk, and doing so simultaneously could
      potentially compromise the results of the tests. Or a performance build
      job may need exclusive access to the test server, in order to have
      consistent results each time.</para>

      <para>The <command>Locks and Latches</command> plugin lets you get
      around this problem to some extent. This plugin lets you set up "locks"
      for certain resources, in a similar way to locks in multi-threaded
      programming. Suppose, for example, in the build jobs depicted in <xref
      linkend="fig-build-dependency-graph-join" />, that the load tests and
      the performance tests run against a dedicated server, but only one build
      job can run against this server at any one time. Imagine furthermore
      that the performance tests for other projects also run against this
      server.</para>

      <para>To avoid contention over the performance server, you could use the
      Locks and Latches plugin to set up a "lock" reserving access to this
      server to a single build job at a time. First, in the System
      Configuration page, you need to add a new lock in the Locks section (see
      <xref linkend="fig-jenkins-build-lock" />). This lock will then be
      available to all build jobs on the server.</para>

      <para><figure id="fig-jenkins-build-lock">
          <title>Configuring a join in the phoenix-web-tests build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/jenkins-build-lock.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>Next, you need to set up each build job that will be using
      the contended resource. In the <command>Build Environment</command>
      section, you will find a <command>Locks</command> field. Tick the
      checkbox and select the lock you just created (see <xref
      linkend="fig-jenkins-build-locks" />). Once you do this for each of the
      build jobs that need to access the resource in question, only one of
      these build jobs will ever be able to run at a given time.</para>

      <para><figure id="fig-jenkins-build-locks">
          <title>Configuring a join in the phoenix-web-tests build job</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata fileref="figs/web/jenkins-build-locks.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Fingerprints</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Aggregating downstream test results</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Build pipelines and promotions</title>

    <para>- M2Release plugin</para>

    <para>- Copying artifacts</para>

    <para>- Build Promotion plugin</para>

    <sect2>
      <title>Managing Maven Releases with the M2Release plugin</title>

      <para></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Conclusion</title>

    <para>TODO</para>
  </sect1>
</chapter>
