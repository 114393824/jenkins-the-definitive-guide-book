<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="chapter-first-steps">
  <title>Your first steps with Jenkins</title>

  <sect1 id="sect-first-steps-introduction">
    <title>Introduction</title>

    <para>In this chapter, we are going to take a quick guided tour through
    some of Jenkin's key features. You'll get to see first-hand just how easy
    it is to install Jenkins and set up your first Jenkins automated build
    job. We won't dwell on the details too much - there are more details to
    come in the following chapters, as well as a detailed chapter on Jenkins
    Administration at the end of the book. This chapter is just an
    introduction. Still, by the end of the chapter, you will also be keeping
    tabs on test results, generating javadoc and publishing code coverage
    reports! We've got a lot of ground to cover, so let's get started!</para>
  </sect1>

  <sect1 id="sect-first-steps-environment">
    <title>Preparing your environment</title>

    <para>There are two ways you can tackle this chapter. You can read through
    it without touching a keyboard, just to get an overview of what Jenkins is
    about. Or you can get your hands dirty, and follow along on your own
    machine.</para>

    <para>If you do want to follow along at home, you may need to set up some
    software on your local machine. Remember, the most basic function of any
    Continuous Integration tool is to monitor source code in a version control
    system and to fetch and build the latest version of your source code
    whenever any changes are committed. So you'll need a version control
    system. In our case, we'll be using git (<uri>http://git-scm.com</uri>).
    The central source code repository for our simple project is stored on
    Github (<uri>https://github.com</uri>). Don't worry about messing up this
    repository with your own changes, though: you'll be creating your own fork
    of the repository that you can use as you wish. If you haven't used git
    and/or don't have an account on Github yet, don't worry, we'll walk
    through the basics, and the whole installation process is well documented
    on the Github web site. We'll explain how to set it all up in great detail
    further on.</para>

    <para>In this chapter, we'll be using Jenkins to build a Java application
    using Maven. <indexterm>
        <primary>maven</primary>
      </indexterm>Maven is a widely-used build tool in the Java world, with
    many powerful features such as declarative dependency management,
    convention over configuration, and a large range of plugins. For our
    build, we will also be using recent versions of the Java Development Kit
    (JDK) and Maven, but if you don't have these installed on your machine,
    don't fret! As we will see, Jenkins will install them for you.</para>

    <sect2>
      <title>Installing Java</title>

      <para>The first thing you will need to install on your machine is Java.
      Jenkins is a Java web application, so you will need at least the Java
      Runtime Environment, or JRE<indexterm>
          <primary>Java</primary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>JRE</secondary>
        </indexterm> to run it. For the examples in this chapter, you will
      need a recent version of Java 6 (these examples were written with Java 6
      update 17, and the latest release at the time of writing was Java 6
      update 19). If you are not sure, you can check this from the command
      line (by opening a DOS console on Windows), and running '<command>java
      -version</command>'. If Java is installed on your machine should get
      something like this:<screen>$ <command>java -version</command>
java version "1.6.0_17"
Java(TM) SE Runtime Environment (build 1.6.0_17-b04-248-10M3025)
Java HotSpot(TM) 64-Bit Server VM (build 14.3-b01-101, mixed mode)</screen></para>

      <para>If you don't have a version already installed, or if your version
      is an older one, download and install the latest JRE installer from the
      Java web site (<ulink
      url="http://java.sun.com/javase/downloads/index.jsp"></ulink>) (see
      <xref linkend="fig-installing-java" />).</para>

      <figure id="fig-installing-java">
        <title>Installing Java</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center" fileref="figs/web/java-install.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect2>

    <sect2>
      <title>Installing Git</title>

      <para>Since we will be using Git, you will need to install and configure
      Git on your machine. If you are new to Git, you might want to run
      through the basics on the Git Reference website
      (<uri>http://gitref.org</uri>). And if you get lost, the whole process
      is well documented on the Github help pages
      (<uri>http://help.github.com</uri>).</para>

      <para>First of all, you need to install Git on your machine. This
      involves downloading the appropriate installer for your operating system
      from the Git website (<uri>http://git-scm.com</uri>). There are packaged
      installers for both Windows and Mac OS X. If you are using Linux, you
      are in Git's home ground: most Linux distributions . On Ubuntu or some
      other Debian-based distribution, you could run something like:<screen>$ <command>sudo apt-get install git-core</command></screen></para>

      <para>On Fedora or another RPM-based distribution, you could use
      <command>yum</command> instead:</para>

      <para><screen>$ <command>sudo yum install git-core</command></screen>And,
      being Linux, you also have the option of installing the application from
      source. There are instructions on how to do this on the Git
      website.</para>

      <para>Once you are done, check that Git is installed and available by
      invoking it from the command line:<screen>$ <command>git --version</command>
git version 1.7.1</screen></para>
    </sect2>

    <sect2>
      <title>Setting up a Github account</title>

      <para>Next, if you don't already have one, you will need to create
      yourself a Github account. This is easy and (for our purposes, at least)
      free of charge, and all the cool kids have one. Go to the Github signup
      page (<uri>https://github.com/plans</uri>) and choose the 'Create a free
      account' option. You will just need to provide a username, a password
      and your email address (see <xref
      linkend="fig-github-signup" />).</para>

      <para><figure id="fig-github-signup">
          <title>Signing up for a Github account</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center" fileref="figs/web/github-signup.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Configuring SSH keys</title>

      <para>Github uses SSH keys to establish a secure connection between your
      computer and the Github servers. Setting these up is not hard, but
      involves a bit of work: fortunately there are clear and detailed
      instructions for each operating system on the Github web site
      (<uri>http://help.github.com/set-up-git-redirect</uri>).</para>
    </sect2>

    <sect2 id="sect-git-fork">
      <title>Forking the sample repository</title>

      <para>As we mentioned earlier, all the sample code for this book is
      stored on Github, at the following URL:
      <uri>https://github.com/wakaleo/game-of-life</uri>. This is a public
      repository, so you can freely view the source code online and check out
      your own working copy. However, if you want to make changes, you will
      need to create your own fork. A fork is a personal copy of a repository
      that you can use as you wish. To create a fork, login to your Github
      account and navigate to the repository URL
      (<uri>https://github.com/wakaleo/game-of-life</uri>). Then click on the
      'Fork' button (see <xref linkend="fig-github-fork" />). This will create
      your own personal copy of the repository.</para>

      <para><figure id="fig-github-fork">
          <title>Forking the sample code repository</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center" fileref="figs/web/github-fork.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>Once you have forked the repository, you should clone a local
      copy to make sure everything is set up correctly. Go to the command line
      and run the following command (replacing "&lt;username"&gt; with your
      own Github username).<screen>$ git clone git@github.com:<emphasis>&lt;username&gt;</emphasis>/game-of-life.git</screen></para>

      <para>This will "clone" (or checkout, in Subversion terms) a copy of the
      project onto your local drive:</para>

      <para><screen><command>git clone git@github.com:john-smart/game-of-life.git</command>
Initialized empty Git repository in /Users/johnsmart/.../game-of-life/.git/
remote: Counting objects: 1783, done.
remote: Compressing objects: 100% (589/589), done.
remote: Total 1783 (delta 1116), reused 1783 (delta 1116)
Receiving objects: 100% (1783/1783), 14.83 MiB | 119 KiB/s, done.
Resolving deltas: 100% (1116/1116), done.</screen>You should now have a local
      copy of the project that you can build and execute. We will be using
      this project later on to trigger changes in the repository.</para>
    </sect2>
  </sect1>

  <sect1 id="sect-first-steps-starting">
    <title>Starting up Jenkins</title>

    <para><indexterm>
        <primary>Jenkins</primary>

        <secondary>Staring using Java Web Start</secondary>
      </indexterm>There are several ways to run Jenkins on your machine. One
    of the easiest way to run Jenkins for the first time is to use Java Web
    Start. Java Web Start is a technology that lets you start up a Java
    application on your local machine via a URL on a web page - it comes
    bundled with the Java JRE. In our case, this will start a Jenkins server
    running on your machine, and let you experiment with it as if it were
    installed locally. All you need for this to work is a recent (Java 6 or
    later) version of the Java Runtime Environment (JRE), which we installed
    in the previous section.</para>

    <para>For convenience, there is a link to the Jenkins Java Web Start
    instance on the book resources page (at <ulink
    url="http://www.wakaleo.com/books/jenkins-the-definitive-guide"></ulink>). Here
    you will find a large orange 'Launch' button in the "Book Resources"
    section (see <xref linkend="fig-hudson-webstart-page" />). You can also
    find this link on the 'Meet Jenkins' page on the Jenkins website (<ulink
    url="http://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins"></ulink>),
    where, if you scroll down far enough, you should find a 'Test Drive'
    section with an identical 'Launch' button.</para>

    <figure id="fig-hudson-webstart-page">
      <title>Running Jenkins using Java Web Start from the Book web
      site</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center" fileref="figs/web/hudson-webstart.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Java Web Start seems to work best on Firefox. When you click on the
    'Launch' button on either of these sites in Firefox, the browser will ask
    if you want to open a file called 'jenkins.jnlp' using Java Web Start.
    Click on OK - this will download Jenkins and start it up on your machine
    (see <xref linkend="fig-first-steps-downloading-hudson" />).</para>

    <para>In other browsers, clicking on this button may simply download the
    JNLP file. In Internet Explorer, you may even need to right click on the
    link and select 'Save Target As' to save the JNLP file, and then run it
    from Windows Explorer. However, in both of these cases, when you open the
    JNLP file, Java Web Start will download and start Jenkins.</para>

    <figure id="fig-first-steps-downloading-hudson">
      <title>Java Web Start will download and run the latest version of
      Jenkins</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/first-steps-downloading-hudson.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Java Web Start will only need to download a particular version of
    Jenkins once. From then on, when you click on the 'Launch' button again,
    Java Web Start will use the copy of Jenkins it has already downloaded
    (that is, until the next version comes out). Ignore any messages your
    operating system or anti-virus software may bring up - it is perfectly
    safe to run Jenkins on your local machine.</para>

    <para>Once it has finished downloading, it will start up Jenkins on your
    machine. You will be able to see it running in a small window called
    "Jenkins Console" (see <xref linkend="fig-first-steps-console" />). To
    stop Jenkins at any time, just close this window.</para>

    <figure id="fig-first-steps-console">
      <title>Java Web Start running Jenkins</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center" fileref="figs/web/first-steps-console.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>There are also installers available for the principal operating
    systems available on the Jenkins web site
    (<uri>http://jenkins-ci.org/</uri>). Or, if you are an experienced Java
    user versed in the ways of WAR files, you may prefer to simply download
    the latest version of Jenkins and run it from the command line. Jenkins
    comes in the form of an executable WAR file - you can download the most
    recent version from the Jenkins website home page (<ulink
    url="http://hudson-ci.org"></ulink>). For convenience, there is also a
    link to the latest version of Jenkins in the Resources section of the book
    website (at <ulink
    url="http://www.continuous-integration-with-hudson.org"></ulink>).</para>

    <para>Once downloaded, you can start Jenkins from the command line as
    shown here:</para>

    <para><screen>$ <command>java -jar jenkins.war</command></screen></para>

    <para>Whether you have started Jenkins using Java Web Start or from the
    command line, Jenkins should now be running on your local machine. By
    default, Jenkins will be running on port 8080, so you can access Jenkins
    in your web browser on <ulink url="http://localhost:8080"></ulink>.</para>

    <para>Alternatively, if you are familiar with Java application servers
    such as Tomcat, you can simply deploy the Jenkins war file to your
    application server - with Tomcat, for example, you could simply place the
    <filename>jenkins.war</filename> file in Tomcat's
    <filename>webapps</filename> directory. If you are running Jenkins on an
    application server, the URL that you use to access Jenkins will be
    slightly different. On a default Tomcat installation, for example, you can
    access Jenkins in your web browser on <ulink
    url="http://localhost:8080/hudson"></ulink>.</para>

    <para>When you open Jenkins in your browser, you should see a screen like
    the one shown in <xref linkend="fig-hudson-start" os="" />. You are now
    ready to take your first steps with Jenkins!</para>

    <figure id="fig-hudson-start">
      <title>The Jenkins start page</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center" fileref="figs/web/jenkins-home.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>
  </sect1>

  <sect1 id="sect-first-steps-configuring">
    <title>Configuring the tools</title>

    <para>Before we get started, we do need to do a little configuration. More
    precisely, we need to tell Jenkins about the build tools and JDK versions
    we will be using for our builds.</para>

    <para>Click on the <indexterm>
        <primary>Jenkins</primary>

        <secondary>Manage Jenkins screen</secondary>
      </indexterm>'Manage Jenkins' link on the home page (see <xref
    linkend="fig-hudson-start" os="" />). This will take you to the 'Manage
    Jenkins' page, the central one-stop-shop for all your Jenkins
    configuration. From this screen, you can configure your Jenkins server,
    install and upgrade plugins, keep track of system load, manage distributed
    build servers, and more! For now, however, we'll keep it simple. Just
    click on the 'Configuring System' link at the top of the list (see <xref
    linkend="fig-hudson-manage" />).</para>

    <figure id="fig-hudson-manage">
      <title>The Manage Jenkins screen</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-manage-hudson.png" width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>This will take you to Jenkins's main configuration screen (see <xref
    linkend="fig-hudson-configure" />). From here you can configure everything
    from security configuration and build tools to email servers, version
    control systems and integration with third-party software. The screen
    contains a lot of information, but most of the fields contain sensible
    default values, so you can safely ignore them for now.</para>

    <figure id="fig-hudson-configure">
      <title>The Configure Jenkins screen</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-system-configuration.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>For now, you will just need to configure the tools required to build
    our sample project. The application we will be building is a Java
    application, built using Maven. So in this case, all we need to do is to
    set up a recent JDK and Maven installation.</para>

    <para>However before we start, take a look at the little blue question
    mark icons lined to the right of the screen. These are Jenkins's
    contextual help buttons. If you are curious about a particular field,
    click on the help icon next to it and Jenkins will display a very detailed
    description about what it is and how it works.</para>

    <sect2>
      <title>Configuring your Maven setup</title>

      <para><indexterm>
          <primary>Maven</primary>
        </indexterm>Let's configure Maven first. Jenkins provides great
      out-of-the-box support for Maven. Scroll down until you reach the
      'Maven' section in the 'Configure System' screen (see <xref lang=""
      linkend="fig-hudson-maven" />).</para>

      <para>Jenkins provides several options when it comes to configuring
      Maven. If you already have Maven installed on your machine, you can
      simply provide the path in the MAVEN_HOME field. Alternatively, you can
      install a Maven distribution by extracting a zip file located in a
      shared directory, or execute a home-rolled installation script. Or you
      can let Jenkins do all the hard work and download Maven for you. To
      choose this option, just tick the 'Install automatically' check box.
      Jenkins will download and install Maven from the Apache web site the
      first time a build job needs it. Just choose the Maven version you want
      to install and Jenkins will do the rest. You will also need to give a
      name for your Maven version (imaginatively called "Maven 2.2.1" in the
      example), so that you can refer to it in your build jobs.</para>

      <para>For this to work, you need to have an Internet connection. If you
      are behind a proxy, you'll need to provide your proxy information - we
      discuss how to set this up in <xref
      linkend="sect-configuration-proxies" />.</para>

      <figure id="fig-hudson-maven">
        <title>Configuring a Maven installation</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-configure-maven.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>One of the nice things about the Jenkins Maven installation
      process is how well it works with remote build agents. Later on in the
      book, we'll see how Jenkins can also run builds on remote build servers.
      You can define a standard way of installing Maven for all of your build
      servers (downloading from the internet, unzipping a distribution bundle
      on a shared server,...) - all of these options will work when you add a
      new remote build agent or set up a new build server using this Jenkins
      configuration.</para>
    </sect2>

    <sect2>
      <title>Configuring the JDK</title>

      <para><indexterm>
          <primary>JDK</primary>
        </indexterm>Once you have configured your Maven installation, you will
      also need to configure a JDK installation (see <xref
      linkend="fig-hudson-jdk" />). Again, if you have a Java JDK (as opposed
      to a Java Runtime Environment - the JDK contains extra development tools
      such as the Java compiler) already installed on your workstation, you
      can simply provide the path to your JDK in the JAVA_HOME field.
      Otherwise, you can ask Jenkins to download the JDK from the <ulink
      url="http://java.sun.com"></ulink> website the first time a build job
      requires it. This is similar to the automatic Maven installation feature
      - just pick the JDK version you need and Jenkins will take care of all
      the logistics. However, for licensing reasons, you will also need to
      tick a check box to indicate that you agree with the Java SDK License
      Agreement.</para>

      <figure id="fig-hudson-jdk">
        <title>Configuring a JDK installation</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-configure-jdk.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Now go to the bottom of the screen and click on the 'Save'
      button.</para>
    </sect2>

    <sect2>
      <title>Notification</title>

      <para>Another important aspect you would typically set up is
      notification. When a Jenkins build breaks, and when it works again, it
      can send out email messages to the team to spread the word. Using
      plugins, you can also get it to send instant messages or SMS messages,
      post entries on Twitter, or get people notified in a few other ways. It
      all depends on what works best for your organizational culture. Email
      notification is easy enough to set up if you know your local SMTP server
      address - just provide this value in the 'Email Notification' section
      towards the bottom of the main configuration page. However, to keep
      things simple, we're not going to worry about notifications just
      yet.</para>
    </sect2>

    <sect2>
      <title>Setting up Git</title>

      <para>The last thing we need to configure for this demo is to get
      Jenkins working with Git. Jenkins comes with support for Subversion and
      CVS out of the box, but you will need to install the Jenkins Git plugin
      to be able to complete the rest of this tutorial. Don't worry, the
      process is pretty simple. First of all, click on the 'Manage Jenkins'
      link to the left of the screen to go back to the main configuration
      screen (see <xref linkend="fig-hudson-manage" />). Then click on 'Manage
      Plugins'. This will open the plugin configuration screen, which is where
      you manage the extra features you want to install on your Jenkins
      server. You should see four tabs: 'Updates', 'Available', 'Installed',
      and 'Advanced' (see <xref
      linkend="fig-jenkins-plugin-manager-installed" />).</para>

      <para><figure id="fig-jenkins-plugin-manager-installed">
          <title>Managing plugins in Jenkins</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-plugin-manager-installed.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>For now, just click on the 'Available' tab. Here you will see
      a very long list of available plugins. Find the 'Git Plugin' entry in
      this list and tick the corresponding checkbox (see <xref
      linkend="fig-jenkins-installing-git" />), and then scroll down to the
      bottom of the screen and click on 'Install'. This will download and
      install the Jenkins Git plugin into your local Jenkins instance.</para>

      <para><figure id="fig-jenkins-installing-git">
          <title>Installing the Git plugin</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-installing-git.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>Once it is done, you will need to restart Jenkins for the
      changes to take effect. To do this, you can simply click on the 'Restart
      Jenkins when no jobs are running' button displayed on the installation
      screen, or alternatively shut down and restart Jenkins by hand.</para>

      <para>That is all we need to configure at this stage. You are now ready
      to set up your first Jenkins build job!</para>
    </sect2>
  </sect1>

  <sect1 id="sect-first-steps-first-job">
    <title>Your first Jenkins build job</title>

    <para>Build jobs are at the heart of the Jenkins build process. Simply
    put, you can think of a Jenkins build job as a particular task or step in
    your build process. This may involve simply compiling your source code and
    running your unit tests. Or you might want a build job to do other related
    tasks, such as running your integration tests, measuring code coverage or
    code quality metrics, generating technical documentation, or even
    deploying your application to a web server. A real project usually
    requires many separate but related build jobs.</para>

    <para>Our sample application is a simple Java implementation of John
    Conway's <indexterm>
        <primary>Game Of Life</primary>
      </indexterm>"Game Of Life"<footnote id="footnote-game-of-life">
        <para>See http://en.wikipedia.org/wiki/Conway's_Game_of_Life</para>
      </footnote>. The Game of Life is a mathematical game which takes place
    on a two dimensional grid of cells, which we will refer to as the
    Universe. Each cell can be either alive or dead. Cells interact with their
    direct neighbours to determine whether they will live or die in the next
    generation of cells. For each new generation of cells, the following rules
    are applied:</para>

    <orderedlist>
      <listitem>
        <para>Any live cell with fewer than two live neighbours dies of
        underpopulation.</para>
      </listitem>

      <listitem>
        <para>Any live cell with more than three live neighbours dies of
        overcrowding.</para>
      </listitem>

      <listitem>
        <para>Any live cell with two or three live neighbours lives on to the
        next generation.</para>
      </listitem>

      <listitem>
        <para>Any dead cell with exactly three live neighbours becomes a live
        cell.</para>
      </listitem>
    </orderedlist>

    <para>Our application is a Java module, built using Maven, that implements
    the core business logic of the Game of Life. We'll worry about the user
    interfaces later on. For now, let's see how we can automate this build in
    Jenkins. If you are not familiar with Maven, or prefer Ant or another
    build framework - don't worry! The examples don't require much knowledge
    of Maven, and we'll be looking at plenty of examples of using other build
    tools later on in the book.</para>

    <para>For our first build job, we will keep it simple: we are just going
    to compile and test our sample application. Click on the 'New Job' link.
    You should get to a screen similar to <xref
    linkend="fig-first-build-job" />. Jenkins supports several different types
    of build job. The two most commonly-used are the free-style builds and the
    Maven 2 builds. The free-style projects allow you to configure just about
    any sort of build job: they are highly flexible and very configurable. The
    Maven 2 builds understand the Maven project structure, and can use this to
    let you set up Maven build jobs with less effort and a few extra features.
    There are also plugins that provide support for other types of build jobs.
    Nevertheless, although our project does use Maven, we are going to use a
    free-style build job, just to keep things simple and general to start
    with. So choose 'Build a free-style software project', as shown in <xref
    linkend="fig-first-build-job" />.</para>

    <para>You'll also need to give your build job a sensible name. In this
    case, call it 'gameoflife-default', as it will be the default CI build for
    our Game Of Life project.</para>

    <para><figure id="fig-first-build-job">
        <title>Setting up your first build job in Jenkins</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center" fileref="figs/web/hudson-new-job.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Once you click on OK, Jenkins will display the project configuration
    screen (see <xref linkend="fig-jenkins-git-new-project" />).</para>

    <para>In a nutshell, Jenkins works by checking out the source code of your
    project and building it in it's own workspace. So the next thing you need
    to do is to tell Jenkins where it can find the source code for your
    project. You do this in the 'Source Code Managment' section (see <xref
    linkend="fig-jenkins-git-new-project" />). Jenkins provides support for
    CVS and Subversion out of the box, and many others such as Git, Mercurial,
    ClearCase, Perforce and many more via plugins.</para>

    <para><indexterm>
        <primary>SCM</primary>

        <secondary>Configuring in Freestyle build jobs</secondary>
      </indexterm>For this project, we will be getting the source code from
    the Github repository we set up earlier. On the Jenkins screen, choose
    'Git' and enter the Repository URL we defined in <xref
    linkend="sect-git-fork" /> (see <xref
    linkend="fig-jenkins-git-new-project" />). Make sure this is the URL of
    your fork, and not of the original repository: it should have the form
    <emphasis>git@github.com:<emphasis><emphasis>&lt;username&gt;</emphasis></emphasis>/game-of-life.git</emphasis>,
    where <emphasis>&lt;username&gt;</emphasis> is the username for your own
    Github account. You can leave all of the other options up until here with
    their default values.</para>

    <figure id="fig-jenkins-git-new-project">
      <title>Telling Jenkins where to find the source code</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/jenkins-git-new-project.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Once we have told Jenkins where to find the source code for our
    application, we need to tell it how often it should check for updates. We
    want Jenkins to monitor the repository and start a build whenever any
    changes have been committed. This is a common way to set up a build job in
    a Continuous Integration context, as it provides fast feedback if the
    build fails. Other approaches include building on regular intervals (for
    example, once a day), requiring a user to kick of the build manually, or
    even triggering a build remotely using a "post-commit" hook in your
    SCM.</para>

    <para><indexterm>
        <primary>Build Triggers</primary>

        <secondary>Configuring in Freestyle build jobs</secondary>
      </indexterm>We configure all of this in the 'Build Triggers' section
    (see <xref linkend="fig-new-job-triggers" />). Pick the 'Poll SCM' option
    and enter '* * * * *' (that's five asterisks) in the Schedule box. Jenkins
    schedules are configured using the <command>cron</command> syntax,
    well-known in the Unix world. The <command>cron</command> syntax consists
    of five fields separated by white space, indicating respectivly the minute
    (0-59), hour (0-23), day of the month (1-31), month (1-12) and the day of
    the week (0-7, with 0 and 7 being Sunday). The star is a wildcard
    character which accepts any valid value for that field. So five stars
    basically means "every minute of every hour of every day". You can also
    provide ranges of values: "* 9-17 * * *" would mean "every minute of every
    day, between 9am and 5pm". You can also space out the schedule using
    intervals: "*/5 * * * *" means "every 5 minutes, for example. Finally,
    there are some other convenient short-hands, such as "@daily" and
    "@hourly".</para>

    <para>Don't worry if your Unix skills are a little rusty - if you click on
    the blue question mark icon on the side of the schedule box, Jenkins will
    bring up a very complete refresher.</para>

    <figure id="fig-new-job-triggers">
      <title>Scheduling the build jobs</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-triggers.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The next step is to configure the actual build itself. In a
    free-style build job, you can break down your build job into a number of
    build steps. This makes it easier to organize builds in clean, separate
    stages. For example, a build might run a suite of functional tests in one
    step, and then tag the build in a second step if all of the functional
    tests succeed. In technical terms, a build step might involve invoking an
    Ant task or a Maven target, or running a shell script. There are also
    Jenkins plugins that let you use additional types of build steps: Gant,
    Grails, Gradle, Rake, Ruby, MSBuild and many other build tools are all
    supported.</para>

    <para><indexterm>
        <primary>Maven</primary>

        <secondary>Configuring in Freestyle build jobs</secondary>
      </indexterm>For now, we just want to run a simple Maven build. Scroll
    down to the 'Build' section and click on the 'Add Build Step' and choose
    'Invoke top-level Maven targets' (see <xref
    linkend="fig-new-job-build-step" />). Then enter 'clean package' in the
    Goals field. If you are not familiar with Maven, this will delete any
    previous build artifacts, compile our code, run our unit tests and
    generates a JAR file.</para>

    <figure id="fig-new-job-build-step">
      <title>Adding a build step</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-build-step.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>By default, this build job will fail if the code does not compile or
    if any of the unit tests fail. That's the most fundamental thing that
    you'd expect of any build server. But Jenkins also does a great job of
    helping you display your test results and test result trends.</para>

    <para>The de facto standard for test reporting in the Java world is an XML
    format used by JUnit. This format is also used by many other Java testing
    tools, such as TestNG, Spock and Easyb. Jenkins understands this format,
    so if your build produces JUnit XML test results, Jenkins can generate
    nice graphical test reports and statistics on test results over time, and
    also let you view the details of any test failures. Jenkins also keeps
    track of how long your tests take to run, both globally, and per test -
    this can come in handy if you need to track down performance
    issues.</para>

    <para>So the next thing we need to do is to get Jenkins to keep tabs on
    our unit tests.</para>

    <para><indexterm>
        <primary>JUnit reports</primary>

        <secondary>Configuring in Freestyle build jobs</secondary>
      </indexterm>Go to the 'Post-build Actions' section (see <xref
    linkend="fig-new-job-test-reports" />) and tick 'Publish JUnit test result
    report' checkbox. When Maven runs unit tests in a project, it
    automatically generates the XML test reports in a directory called
    <filename>surefire-reports</filename> in the <filename>target</filename>
    directory. So enter "**/target/surefire-reports/*.xml" in the 'Test report
    XMLs' field. The two asterisks at the start of the path ('**') are a best
    practice to make the configuration a bit more robust: they allow Jenkins
    to find the target directory no matter how we have configured Jenkins to
    check out the source code.</para>

    <para>Another thing you often want to do is to archive your build results.
    Jenkins can store a copy of the binary artifacts generated by your build,
    allowing you to download the binaries produced by a build directly from
    the build results page. It will also post the latest binary artifacts on
    the project home page, which is a convenient way to distribute the latest
    and greatest version of your application. You can activate this option by
    ticking the 'Archive the artifacts' checkbox and indicating which binary
    artifacts you want Jenkins to archive. In <xref
    linkend="fig-new-job-test-reports" />, for example, we have configured
    Jenkins to store all of the JAR files generated by this build job.</para>

    <figure id="fig-new-job-test-reports">
      <title>Configuring JUnit test reports and artifact archiving</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-tests-no-email.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Now we're done - just click on the Save button at the bottom of the
    screen. Our build job should now be ready to run. So let's see it in
    action!</para>
  </sect1>

  <sect1 id="sect-first-steps-first-job-in-action">
    <title>Our first build job in action</title>

    <para>Once you save your new build job, Jenkins will display the home page
    for this job (see <xref linkend="fig-new-job-running" />). This is where
    Jenkins displays details about the latest build results and the build
    history.</para>

    <para>If you wait a minute or so, the build should kick off automatically
    - you can see the stripy progress bar in the 'Build History' section in
    the bottom left hand corner of <xref linkend="fig-new-job-running" />. Or,
    if you are impatient, you can also trigger the build manually using the
    'Build Now' button.</para>

    <figure id="fig-new-job-running">
      <title>Your first build job running</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-running.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>The build will also now figure proudly on your Jenkins server's home
    page (see <xref linkend="fig-hudson-dashboard" />). This page shows a
    summary of all of your build jobs, including the current build status and
    general state of heath of each of your builds. It tells you when each
    build ran successfully for the last time, and when it last failed, and
    also the result of the last build.</para>

    <para>Once of Jenkins's specialities is the way it lets you get an idea of
    build behaviour over time. For example, Jenkins uses a weather metaphor to
    help give you an idea of the stability of your builds. Essentially, the
    more your builds fail, the worse the weather gets. This helps you get an
    idea of whether a particular broken build is an isolated event, or if the
    build is breaking on a regular basis, in which case it might need some
    special attention.</para>

    <para>You can also manually trigger a build job here, using the build
    schedule button (that's the one that looks a bit like a green play button
    on top of a clock).</para>

    <figure id="fig-hudson-dashboard">
      <title>The Jenkins dashboard</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-home-job-list.png" width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>When the build finishes, the ball in the Build History box becomes
    solid blue. This means the build was a success. Build failures are
    generally indicated by a red ball. For some types of project, you can also
    distinguish between a build error (such as a compiler error), indicated by
    a red ball, and other sorts of build failures, such as unit test failures
    or insufficient code coverage, which are indicated by a yellow ball. There
    are also some other details about the latest test results, when the last
    build was run, and so on. But before we look at the details, let's get
    back to the core business model of a Continuous Integration server -
    kicking off builds when someone changes the code!</para>

    <para>We are going to commit a code change to Github and see what happens,
    using the source code we checked out in <xref linkend="sect-git-fork" />.
    We now have Jenkins configured to monitor our Githib fork, so if we make
    any changes, Jenkins should be able to pick them up.</para>

    <para>So let's make a change. The idea is to introduce a code change that
    will cause the unit tests to fail. If your Java is a bit rusty, don't
    worry, you won't need to know any Java to be able to break the build -
    just follow the instructions!</para>

    <para>Now in normal development, you would first modify the unit test that
    describes this behaviour. Then you would verify that the test fails with
    the existing code, and implement the code to ensure that the test passes.
    <emphasis>Then</emphasis> you would commit your changes to your version
    control system, allowing Jenkins to build them. However this would be a
    poor demonstration of how Jenkins handles unit test failures. So in this
    example, we will, against all best practices, simply modify the
    application code directly.</para>

    <para>First of all, open the <filename>Cell.java</filename> file, which
    you will find in the
    <filename>gameoflife-core/src/main/java/com/wakaleo/gameoflife/domain</filename>
    directory. Open this file in your favorite text editor. You should see
    something like this:</para>

    <programlisting>package com.wakaleo.gameoflife.domain;

public enum Cell {
    LIVE_CELL("*"), DEAD_CELL(".");

    private String symbol;

    private Cell(String symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return symbol;
    }

    static Cell fromSymbol(String symbol) {
        Cell cellRepresentedBySymbol = null;
        for (Cell cell : Cell.values()) {
            if (cell.symbol.equals(symbol)) {
                cellRepresentedBySymbol = cell;
                break;
            }
        }
        return cellRepresentedBySymbol;
    }

    public String getSymbol() {
        return symbol;
    }
}</programlisting>

    <para>The application can print the state of the grid as a text array.
    Currently, the application prints our live cells as an asterisk ('*'), and
    dead cells appear as a minus character ('-'). So a five-by-five grid
    containing a single living cell in the center would look like
    this:<screen>-----
--*--
-----</screen>Now users have asked for a change the application - they want
    pluses ('*+') instead of stars! So we are going to make a slight change to
    the <code>Cell</code> class method, and rewrite it as follows (the
    modifications are in <command>bold</command>):</para>

    <programlisting>package com.wakaleo.gameoflife.domain;

public enum Cell {
    <command>LIVE_CELL("+")</command>, DEAD_CELL(".");

    private String symbol;

    private Cell(String symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return symbol;
    }

    static Cell fromSymbol(String symbol) {
        Cell cellRepresentedBySymbol = null;
        for (Cell cell : Cell.values()) {
            if (cell.symbol.equals(symbol)) {
                cellRepresentedBySymbol = cell;
                break;
            }
        }
        return cellRepresentedBySymbol;
    }

    public String getSymbol() {
        return symbol;
    }
}</programlisting>

    <para>Save this change, and then commit them to the local Git repository
    by running "<command>git commit</command>": <screen>$ <command>git commit -a -m "Changes stars to pluses"</command>
[master 61ce946] Changes stars to pluses
 1 files changed, 1 insertions(+), 1 deletions(-)</screen>This will commit the
    changes locally, but since Git is a distributed repository, you now have
    to push these changes through to your fork on Github. You do this by
    running "<command>git push</command>":<screen>$ <command>git push</command>
Counting objects: 21, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (7/7), done.
Writing objects: 100% (11/11), 754 bytes, done.
Total 11 (delta 4), reused 0 (delta 0)
To git@github.com:john-smart/game-of-life.git
   7882d5c..61ce946  master -&gt; master</screen></para>

    <para><indexterm>
        <primary>Build failures</primary>
      </indexterm>Now go back to the Jenkins web page. After a minute or so, a
    new build should kick off, and fail. In fact, there are several other
    places which are affected by this change, and the regression tests related
    to these features are now failing. On the build job home page, you will
    see a second build in the build history with an ominous red ball (see
    <xref linkend="fig-new-job-failed" />) - this tells you that the latest
    build has failed.</para>

    <para>You might also notice some clouds next to the Build History title -
    this is the same "weather" icon that we saw on the home page, and serves
    the same purpose - to give you a general idea of how stable your build is
    over time.</para>

    <figure id="fig-new-job-failed">
      <title>A failed build</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-failed.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>If you click on the new build history entry, Jenkins will give you
    some more details about what went wrong (see <xref
    linkend="fig-new-job-failure-details" />). Jenkins tells us that there
    were 11 new test failures in this build, something which can be seen at a
    glance in the <indexterm>
        <primary>Test Result Trend</primary>
      </indexterm>Test Result Trend graph - red indicates test failures. You
    can even see which tests are failing, and how long they have been
    broken.</para>

    <figure id="fig-new-job-failure-details">
      <title>The list of all the broken tests</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-failure-details.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>If you want to know exactly what went wrong, that's easy enough to
    figure out as well. If you click on the failed test classes, Jenkins
    brings up the actual details of the test failures (see <xref
    linkend="fig-hudson-new-job-test-failure-details" />), which is a great
    help when it comes to reproducing and fixing the issue.</para>

    <figure id="fig-hudson-new-job-test-failure-details">
      <title>Details about a failed test</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-test-failure-details.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Jenkins displays a host of information about the failed test in a
    very readable form, including the error message the test produced, the
    stack trace, how long the test has been broken, and how long it took to
    run. Often, this in itself is enough to put a developer on the right track
    towards fixing the issue.</para>

    <para>Now let's fix the build. To make things simple, we'll just back out
    our changes and recommit the code in it's original state (the end users
    just changed their mind about the asterisks, anyway). So just undo the
    changes you made to the <filename>Cell</filename> class (again, the
    changes are highlighted in <command>bold</command>):</para>

    <programlisting>package com.wakaleo.gameoflife.domain;

public enum Cell {
    <command>LIVE_CELL("*")</command>, DEAD_CELL(".");

    private String symbol;

    private Cell(String symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return symbol;
    }

    static Cell fromSymbol(String symbol) {
        Cell cellRepresentedBySymbol = null;
        for (Cell cell : Cell.values()) {
            if (cell.symbol.equals(symbol)) {
                cellRepresentedBySymbol = cell;
                break;
            }
        }
        return cellRepresentedBySymbol;
    }

    public String getSymbol() {
        return symbol;
    }
}</programlisting>

    <para>When you've done this, commit your changes again:<screen>$ <command>git commit -a -m "Restored the star"</command>
[master bc924be] Restored the star
 1 files changed, 1 insertions(+), 1 deletions(-)
$ <command>git push</command>
Counting objects: 21, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (7/7), done.
Writing objects: 100% (11/11), 752 bytes, done.
Total 11 (delta 4), reused 6 (delta 0)
To git@github.com:john-smart/game-of-life.git
   61ce946..bc924be  master -&gt; master</screen>Once you've committed these
    changes, Jenkins should pick them up and kick off a build. Once this is
    done, you will be able to see the fruit of your work on the build job home
    page (see <xref linkend="fig-new-job-fixed-build" />) - the build status
    is blue again and all is well. Also notice the way we are building up a
    trend graph showing the number of succeeding unit tests over time - this
    sort of report really is one of Jenkins's strong points.</para>

    <figure id="fig-new-job-fixed-build">
      <title>Now the build is back to normal</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-new-job-fixed.png" width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>
  </sect1>

  <sect1 id="sect-first-steps-javadocs">
    <title>More reporting - displaying Javadocs</title>

    <para><indexterm>
        <primary>Javadocs</primary>
      </indexterm>For many Java projects, Javadoc comments are an important
    source of low-level technical documentation. There are even tools, such as
    UmlGraph, that let you produce Javadoc with embedded UML diagrams to give
    you a better picture of how the classes fit together in the application.
    This sort of technical documentation has the advantage of being cheap to
    produce, accurate and always up-to-date.</para>

    <para>Jenkins can integrate Javadoc API documentation directly into the
    Jenkins web site. This way, everyone can find the latest Javadoc easily,
    in a well known place. Often, this sort of task is performed in a separate
    build job, but for simplicity we are going to add another build step to
    the gameoflife-default build job to generate and display Javadoc
    documention for the Game Of Life API.</para>

    <para>Start off by going into the 'gameoflife-default' configuration
    screen again. Click on 'Add build step', and add a new build step to
    'Invoke top level Maven targets' (see <xref
    linkend="fig-hudson-freestyle-javadoc-build-step" />). In the Goals field,
    place <command>javadoc:javadoc</command> - this will tell Maven to
    generate the Javadoc documentation.</para>

    <figure id="fig-hudson-freestyle-javadoc-build-step">
      <title>Adding a new build step and report to generate Javadoc</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-freestyle-javadoc-build-step.png"
                     width="10.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Now go to the 'Post-build Action' and tick the 'Publish Javadoc'
    checkbox. This project is a multi-module project, so a separate
    sub-directory is generated for each module (core, services, web and so
    forth). For this example, we are interested in displaying the
    documentation for the core module. In the 'Javadoc directory' field, enter
    <filename>gameoflife-core/target/site/apidocs</filename> - this is where
    Maven will place the Javadocs it generates for the core module. Jenkins
    may display an error message saying that this directory doesn't exist at
    first.s Jenkins is correct - this directory won't exist until we run the
    <command>javadoc:javadoc</command> goal, but since we haven't run this
    command yet we can safely ignore the message at this stage.</para>

    <para>If you tick 'Retain Javadoc for each successful build, Jenkins will
    also keep track of the Javadocs for previous builds - not always useful,
    but it can come in handy at times.</para>

    <para>Now trigger a build manually. You can do this either from the build
    job's home page (using the "Build Now" link), or directly from the server
    home page. Once the build is finished, open the build job summary page.
    You should now see a Javadoc link featuring prominently on the screen -
    this link will open the latest version of the Javadoc documentation (see
    <xref linkend="fig-hudson-javadoc-results" />). You will also see this
    link on the build details page, where it will point to the Javadoc for
    that particular build, if you have asked Jenkins to store Javadoc for each
    build.</para>

    <figure id="fig-hudson-javadoc-results">
      <title>Jenkins will add a Javadoc link to your build results</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-build-with-javadoc.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>
  </sect1>

  <sect1 id="sect-first-steps-metrics">
    <title>Adding Code Coverage and other metrics</title>

    <para><indexterm>
        <primary>Code Coverage</primary>
      </indexterm>Reporting is one of Jenkins's strong points. We have seen
    how easy it is to display test results and to publish Javadocs, but you
    can publish a large number of other very useful reports using Jenkins's
    plugins.</para>

    <para>Plugins are another one of Jenkins's selling points - there are
    plugins for doing just about anything, from integrating new build tools or
    version control systems to notification mechanisms and reporting. In
    addition, Jenkins plugins are very easy to install and integrate smoothly
    into the existing Jenkins architecture.</para>

    <para>To see how the plugins work, we are going to integrate code coverage
    metrics using the Cobertura plugin. Code coverage is an indication of how
    much of your application code is actually executed during your tests - it
    can be a useful tool in particular for finding areas of code that have not
    been tested by your test suites. It can also give some indication as to
    how well a team is applying good testing practices such as test-driven
    development or behaviour-driven development.</para>

    <para>Cobertura (<ulink url="http://cobertura.sourceforge.net"></ulink>)
    is an open source code coverage tool that works well with both Maven and
    Jenkins. Our Maven demonstration project is already configured to record
    code coverage metrics, so all we need to do is to install the Jenkins
    Cobertura plugin and generate the code coverage metrics for Jenkins to
    record and display.</para>

    <figure id="fig-hudson-plugin-manager">
      <title>Jenkins has a large range of plugins available</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-plugin-manager.png "
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>To install a new plugin, go to the 'Manage Jenkins' page and click
    on the 'Manage Plugins' entry. This will display a list of the available
    plugins as well as the plugins already installed on your server (see <xref
    linkend="fig-hudson-plugin-manager" />). If your build server doesn't have
    an internet connection, you can also manually install a plugin by
    downloading the plugin file elsewhere and uploading it to your Jenkins
    installation (just open the 'Advanced' tab in <xref
    linkend="fig-hudson-plugin-manager" />), or by copying the plugin to the
    <filename>$JENKINS_HOME/plugins</filename> directory.</para>

    <para>In our case, we are interested in the Cobertura plugin, so go to the
    'Available' tab and scroll down until you find the 'Cobertura Plugin'
    entry in the 'Build Reports section. Click on the check box and then click
    on the 'Install' button at the bottom of the screen.</para>

    <para>This will download and install the plugin for you. Once it is done,
    you will need to restart your Jenkins instance to see the fruits of your
    labor. When you have restarted Jenkins, go back to the 'Manage Plugins'
    screen and click on the 'Installed' tab - there should now be a 'Cobertura
    Plugin' entry in the list of installed plugins on this page.</para>

    <para>Once you have made sure the plugin was successfully installed, go to
    the configuration page for the 'gameoflife-default' build job.</para>

    <para>To set up code coverage metrics in our project, we need to do two
    things. First we need to generate the Cobertura coverage data in an XML
    form that Jenkins can use; then we need to configure Jenkins to display
    the coverage reports.</para>

    <para>Our Game Of Life project already has been configured to generate XML
    code coverage reports if we ask it. All you need to do is to run
    <command>mvn cobertura:cobertura</command> to generate the reports in XML
    form. Cobertura can also generate HTML reports, but in our case we will be
    letting Jenkins take care of the reporting, so we can save on build time
    by not generating the For this example, for simplicity, we will just add
    the <command>cobertura:cobertura</command> goal to the second build step
    (see <xref linkend="fig-hudson-cobertura-build-step" />). You could also
    add a new build step just for the code coverage metrics. In a real-world
    project, code quality metrics like this are typically placed in a distinct
    build job, which is run less frequently than the default build.</para>

    <figure id="fig-hudson-cobertura-build-step">
      <title>Adding another Maven goal to generating test coverage
      metrics</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-cobertura-build-step.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Next, we need to tell Jenkins to keep track of our code coverage
    metrics. Scroll down to the 'Post-build Actions' section. You should see a
    new check box labeled 'Publish Cobertura Reports'. Jenkins will often add
    UI elements like this when you install a new plugin. When you tick this
    box, Jenkins will display the configuration options for the Cobertura
    plugin that we installed earlier (see <xref
    linkend="fig-hudson-cobertura-config" />).</para>

    <para>Like most of the code-quality related plugins in Jenkins, the
    Cobertura plugin lets you fine-tune not only the way Jenkins displays the
    report data, but also how it interprets the data. In the 'Coverage Metrics
    Targets' section, you can define what you consider to be the minimum
    acceptable levels of code coverage. In <xref
    linkend="fig-hudson-cobertura-config" />, we have configured Jenkins to
    list any builds with less than 50% test coverage as "unstable" (indicated
    by a yellow ball), and notify the team accordingly.</para>

    <figure id="fig-hudson-cobertura-config">
      <title>Configuring the test coverage metrics in Jenkins</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-config-cobertura.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>This fine-tuning often comes in handy in real-world builds. For
    example, you may want to impose a special code coverage constraint in
    release builds, to ensure high code coverage in release versions. Another
    strategy that can be useful for legacy projects is to gradually increase
    the minimum tolerated code coverage level over time. This way you can
    avoid having to retro-fit unit tests on legacy code just to raise the code
    coverage, but you do encourage all new code and bug fixes to be well
    tested.</para>

    <para>Now trigger a build manually. The first time you run the build job
    with Cobertura reporting activated, you will see coverage statistics for
    your build displayed on the build home page, along with a 'Coverage
    Report' link when you can go for more details (see <xref
    linkend="fig-hudson-initial-coverage-report" />). The Cobertura report
    shows different types of code coverage for the build we just ran. Since we
    have only run the test coverage metrics once, the coverage will be
    displayed as red and green bars.</para>

    <figure id="fig-hudson-initial-coverage-report">
      <title>Jenkins displays code coverage metrics on the build home
      page</title>

      <mediaobject>
        <imageobject role="web">
          <imagedata align="center"
                     fileref="figs/web/hudson-initial-coverage-report.png"
                     width="4.3in" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>If you click on the Coverage Report icon, you will see code coverage
    for each package in your application, and even drill down to see the code
    coverage (or lack thereof) for an individual class (see <xref
    linkend="fig-hudson-code-coverage-class" />). When you get to this level,
    Jenkins displays both the overall coverage statistics for the class, and
    also highlights the lines that were executed in green, and those that
    weren't in red.</para>

    <para>This reporting gets better with time. Jenkins not only reports
    metrics data for the latest build, but also keeps track of metrics over
    time, so that you can see how they evolve throughout the life of the
    project.</para>

    <para>For example, if you drill down into the coverage reports, you will
    notice that certain parts of this code are not tested (for example the
    <filename>Cell.java</filename> class in <xref
    linkend="fig-hudson-code-coverage-class" />). <figure
        id="fig-hudson-code-coverage-class">
        <title>Jenkins lets you display code coverage metrics for packages and
        classes</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-code-coverage-class.png "
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Code coverage metrics are a great way to isolate code that has not
    been tested, in order to add extra tests for corner cases that were not
    properly tested during the initial development, for example. The Jenkins
    code coverage graphs are also a great way of keeping track of your code
    coverage metrics as the project grows. Indeed, as you add new tests, you
    will notice that Jenkins will display a graph of code coverage over time,
    not just the latest results (see <xref lang=""
    linkend="fig-hudson-code-coverage-graph" />).<figure
        id="fig-hudson-code-coverage-graph">
        <title>Jenkins also displays a graph of code coverage over
        time</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/hudson-code-coverage-graph.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>Note that our objective here is not to improve the code coverage
    just for the sake of improving code coverage - we are adding an extra test
    to verify some code that was not previously tested, and as a result the
    code coverage goes up. There is a subtle but important difference here -
    code coverage, as with any other metric, is very much a means to an end
    (high code quality and low maintenance costs), and not an end in
    itself.</para>

    <para>Nevertheless, metrics like this can give you a great insight into
    the health of your project, and Jenkins presents them in a particularly
    accessible way.</para>

    <para>This is just one of the code quality metrics plugins that have been
    written for Jenkins. There are many more (over fifty reporting plugins
    alone at the time of writing). We'll look at some more of them in the
    chapter on Continuous Code Quality.</para>
  </sect1>

  <sect1>
    <title id="sect-first-steps-conclusion">Conclusion</title>

    <para>In this chapter, we have gone through what you need to know to get
    started with Jenkins. You should be able to set up a new build job, and
    setting up reporting on JUnit test results and javadocs. And you have seen
    how to add a reporting plugin and keep tabs on code coverage. Well done!
    But there's still a lot more to learn about Jenkins - in the following
    chapters, we will be looking at how Jenkins can help you improve your
    build automation process in many other areas as well.</para>
  </sect1>
</chapter>
