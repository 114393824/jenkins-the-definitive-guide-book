<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="chapter-build-jobs">
  <title>Distributed builds</title>

  <sect1 id="sect-build-jobs-introduction">
    <title>Introduction</title>

    <para><indexterm>
        <primary>distributed build</primary>
      </indexterm>Arguably one of the more powerful features of Jenkins is its
    ability to dispatch build jobs across a large number of machines. It is
    quite easy to set up a farm of build servers, either to share the load
    across multiple machines, or to run build jobs in different environments.
    This is a very effective strategy which can potentially increase the
    capacity of your CI infrastructure dramatically.</para>

    <para>Distributed builds are generally used either to absorb extra load,
    for example absorbing spikes in build activity by dynamically adding extra
    machines as required, or to run specialized build jobs in specific
    operating systems or environments. For example, you may need to run
    particular build jobs on a particular machine or operating system. For
    example, if you need to run web tests using Internet Explorer, you will
    need to be use a Windows machine. Or one of your build jobs may be
    particularly resource-heavy, and need to be run on its own dedicated
    machine so as not to penalize your other build jobs.</para>

    <para>Demand for build servers can also fluctuate over time. If you are
    working with product release cycles, you may need to run a much higher
    number of builds jobs towards the end of the cycle, for example, when more
    comprehensive functional and regression test suites may be more
    frequent.</para>

    <para>In this chapter, we will discuss how to set up and manage a farm of
    build servers using Hudson.</para>
  </sect1>

  <sect1 id="sect-build-jobs">
    <title>The Jenkins Distributed Build Architecture</title>

    <para>Jenkins uses a master/slave architecture to manage distributed
    builds. Your main Jenkins server (the one we have been using up until
    present) is the master. In a nutshell, the master's job is to handle
    scheduling build jobs, dispatching builds to the slaves for the actual
    execution, monitor the slaves (possibly taking them on and off-line as
    required) and recording and presenting the build results. Even in a
    distributed architecture, a master instance of Jenkins can also execute
    build jobs directly.</para>

    <para>The job of the slaves is to do as they are told, which involves
    executing build jobs dispatched by the master. You can configure a project
    to always run on a particular slave machine, or a particular type of slave
    machine, or simply let Jenkins pick the next available slave.</para>

    <para>A slave is a small Java executable that runs on a remote machine and
    listens for requests from the Jenkins master instance. Slaves can (and
    usually do) run on a variety of operation systems. The slave instance can
    be started in a number of different ways, depending on the operating
    system and network architecture. Once the slave instance is running, it
    communicates with the master instance over a TCP/IP connection. We will
    look at different setups in the rest of this chapter.</para>
  </sect1>

  <sect1>
    <title>Master/Slave strategies in Jenkins</title>

    <para>There are a number of different ways that you can set up a
    distributed build farm using Hudson, depending on your operating systems
    and network architecture. In all cases, the fact that a build job is being
    run on a slave, and how that slave is managed, is transparent for the
    end-user: the build results and artifacts will always end up on the master
    server.</para>

    <para>Creating a new Jenkins slave node is a straight-forward process.
    First, go to the Manage Jenkins screen and click on 'Manage Nodes'. This
    screen displays the list of slave agents (also known as 'Nodes' in more
    politically correct terms) (see <xref
    linkend="fig-jenkins-manage-nodes" />). From here, you can set up new
    nodes by clicking on the 'New Node' button. You can also configure some of
    the parameters related to your distributed build setup (see <xref
    linkend="node-monitoring" />).</para>

    <para><figure id="fig-jenkins-manage-nodes">
        <title>Jenkins supports four main types of build job.</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/jenkins-manage-nodes.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure>There are several different strategies when it comes to
    managing Jenkins slave nodes, depending on your target operating systems
    and other architectural considerations. These strategies affect the way
    you configure your slave nodes, so we need to consider them separately.
    The main approaches are:</para>

    <itemizedlist>
      <listitem>
        <para>The master starts the slave agents via ssh</para>
      </listitem>

      <listitem>
        <para>You start the slave agent manually using Java Web Start</para>
      </listitem>

      <listitem>
        <para>You start the slave agent directly from the command line on the
        slave machine from the command line</para>
      </listitem>

      <listitem>
        <para>The master starts the slave agents as a remote Windows
        service</para>
      </listitem>

      <listitem>
        <para>You write your own script to start the slave agents from the
        master machine</para>
      </listitem>
    </itemizedlist>

    <para>Each of these strategies has its uses, advantages and
    inconveniences. Let's look at each in turn.</para>

    <sect2>
      <title>The master starts the slave agent using SSH</title>

      <para>If you are working in a Unix environment, the most convenient way
      to start a Jenkins slave is undoubtedly to use SSH. Jenkins has its own
      build-in SSH client, and almost all Unix environments support SSH
      (usually <command>sshd</command>) out of the box.</para>

      <para>To create a Unix-based slave, click on the 'New Node' button as we
      mentioned above. This will prompt you to enter the name of your slave,
      and it's type (see <xref linkend="fig-jenkins-new-slave" />). At the
      time of writing, only 'Dumb slaves' are supported out-of-the-box: "dumb"
      slaves are passive beasts, that simply respond to build job requests
      from the master node. This is the most common way to set up a
      distributed build architecture, and the only option available in a
      default installation.</para>

      <para><figure id="fig-jenkins-new-slave">
          <title>Creating a new slave node</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-new-slave.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>In this screen, you simply need to provide a name for your slave.
      When you click on 'OK', Jenkins will let you provide more specific
      details about your slave machine (see <xref
      linkend="fig-jenkins-slave-ssh" />).</para>

      <para><figure id="fig-jenkins-slave-ssh">
          <title>Creating a Unix slave node</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-slave-ssh.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>The name is simply a unique way of identifying your slave
      machine. It can be anything, but it may help if the name reminds you of
      the physical machine it is running on. It also helps if the name is
      file-system and URL-friendly. It will work with spaces, but you will
      make life easier for yourself if you avoid them. So "slave-1" is better
      than "Slave 1".</para>

      <para>The description is also purely for human consumption, and can be
      used to indicate why you would use this slave rather than
      another.</para>

      <para>Like on the main Jenkins configuration screen, the number of
      executors lets your define how many concurrent build job this node can
      execute.</para>

      <para>Every Jenkins slave node also needs a place that it can call home,
      or, more precisely, a dedicated directory on the slave machine that the
      slave agent can use to run build jobs. You define this directory in the
      Remote FS root field. You need to provide a local, OS-specific path,
      such as <filename>/var/jenkins</filename> for a Unix machine, or
      <filename>C:\jenkins</filename> on Windows. Nothing mission-critical is
      stored in this directory - everything important is transferred back to
      the master machine once the build is done. So you usually don't need to
      be so concerned with backing up these directories as you should be with
      the master.</para>

      <para>Labels are a particularly useful concept when your distributed
      build architecture begins to grow in size. You can define labels, or
      tags, to each build node, and then configure a build job to run only on
      a slave node with a particular label. Labels might relate to operating
      systems (unix, windows, macosx,...), environments (staging, uat,
      development,...) or any criteria that you find useful. For example, you
      could configure your automated WebDriver/Selenium tests to run using
      Internet Explorer, but only on slave nodes with the 'windows'
      label.</para>

      <para>The 'Usage' field lets you configure how intensively Hudson will
      use this slave. You have the choice of two options: use it as much as
      possible, or reserve it for dedicated build jobs. The first option,
      'Utilize this slave as much as possible', tells Jenkins to use this
      slave freely as soon as it becomes available, for any build job that it
      can run. This is by far the most commonly used one, and is generally
      what you want.</para>

      <para>There are times, however, when this second option comes in handy.
      In the project configuration, you can tie a build job to a specific node
      - this is useful when a particular task, such as automated deployment or
      a performance test suite, needs to be executed on a specific machine. In
      this case, the 'Leave this machine for tied jobs only' option makes good
      sense. You can take this further by setting the maximum number of
      Executors to 1. In this case, not only will this slave be reserved for a
      particular type of job, but it will only ever be able be able to run one
      of these build jobs at any one time. This is a very useful configuration
      for performance and load tests, where you need to reserve the machine so
      that it can execute its tests without interference.</para>

      <para>The launch method is where you decide how Hudson will start the
      node, as we mentioned earlier. For the configuration we are discussing
      here, you would choose 'Launch slave agents on Unix machines via SSH'.
      The 'Advanced' button lets you enter the additional details that Jenkins
      needs to connect to the Unix slave machine: a host name, a login and
      password, and a port number. You can also provide a path to the SSH
      private key file on the master machine (e.g. id_dsa or id_rsa) to use
      for "password-less" Public/Private Key authentication.</para>

      <para>You can also configure when Jenkins starts and stops the slave. By
      default, Jenkins will simply keep the slave running and use it whenever
      required (the 'Keep this slave on-line as much as possible' option). If
      Jenkins notices that the slave has gone offline (for example due to a
      server reboot), it will attempt to restart it if it can. Alternatively,
      Jenkins can be more conservative with your system resources, and take
      the slave offline when it doesn't need it. To do this, simple choose the
      'Take this slave on-line when in demand and off-line when idle' option.
      This is useful if you have regular spikes and lulls of build activity,
      as an unused slave can be taken offline to conserve system resources for
      other tasks, and brought back online when required.</para>

      <para>Jenkins also needs to know where it can find the build tools it
      needs for your build jobs on the slave machines. This includes JDKs as
      well as build tools such as Maven, Ant and Gradle. If you have
      configured your build tools to be automatically installed, you will
      usually have no extra configuration to do for your slave machines:
      Jenkins will download and install the tools as required. On the other
      hand, if your build tools are installed locally on the slave machine,
      you will need to tell Jenkins where it can find them. You do this by
      ticking the 'Tool Locations' checkbox, and providing the local paths for
      each of the tools you will need for your build jobs (see <xref
      linkend="sect-configuration-jdk" />).</para>

      <para><figure id="fig-jenkins-slave-nodes">
          <title>Configuring tool locations</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-slave-tools.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>You can also specify environment variables. These will be
      passed into your build jobs, and can be a good way to allow your build
      jobs to behave differently depending on where they are being
      executed.</para>
    </sect2>

    <sect2>
      <title>Starting the slave agent manually using Java Web Start</title>

      <para>Another option is to start a slave agent from the slave machine
      itself using Java Web Start (JNLP). This approach is useful if the
      server cannot connect to the slave, for example if the slave machine is
      running on the other side of a firewall. It works no matter what
      operating system your slave is running on, however it is more commonly
      used for Windows slaves. It does suffer from a few major drawbacks: the
      slave node cannot be started, or restarted, automatically by Jenkins.
      So, if the slave goes down, the master instance cannot restart
      it.</para>

      <para>When you do this on a Windows machine, you need to start the
      Jenkins slave manually at least once. This involves opening a browser on
      the machine, opening the slave node page on the Jenkins master, and
      launching the slave using a very visible JNLP icon. However, once you
      have launched the slave, you can install it as a Windows service.</para>

      <para>There are also times when you need to do this from the command
      line, in a Unix environment. You may need to do this because of
      firewalls or other networking issues, or because SSH is not available in
      your environment.</para>

      <para>Lets step through both these processes. </para>

      <para>The first thing you need to do in all cases is create a new slave.
      As for any other slave node, you do this by clicking on the 'New Node'
      menu entry in the Nodes screen. When entering the details concerning
      your slave node, make sure you choose 'Launch slave agents via JNLP' in
      the <command>Launch Method</command> field (see <xref
      linkend="fig-jenkins-jnlp-slave" />). Also remember that if this is to
      be a Windows slave node, the Remote FS root needs to be a Windows path
      (such as <filename>C:\jenkins-slave</filename>). This directory does not
      have to exist: Jenkins will create it automatically if it is
      missing.</para>

      <para><figure id="fig-jenkins-jnlp-slave">
          <title>Creating a slave node for JNLP</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-slave-jnlp.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure>Once you have saved this configuration, Next, log on to the
      slave machine and open the Slave node screen in a browser, as shown in
      <xref linkend="fig-jenkins-launch-jnlp" />. You will see a large orange
      Launch button: if you click on this button, you should be able to start
      a slave agent directly from within your browser.</para>

      <para><figure id="fig-jenkins-launch-jnlp">
          <title>Launching a slave via Java Web Start</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-launch-jnlp.png"
                         width="12.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>If all goes well, this will open up a small window indicating that
      your slave agent is now running (see <xref
      linkend="fig-jenkins-slave-agent" />).</para>

      <para><figure id="fig-jenkins-slave-agent">
          <title>The Jenkins slave agent in action</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-slave-agent.png"
                         width="2.3in" />
            </imageobject>
          </mediaobject>
        </figure>Browsers are fickle, however, and Java Web Start is not
      always easy to use. This approach usually works best with Firefox,
      although you must have installed the Java JRE beforehand to make Firefox
      Java-aware. Using JNLP with Internet Explorer requires some
      (considerable) fiddling to associate <filename>*.jnlp</filename> files
      with the Java Web Start executable, a file called
      <command>javaws</command>, which you will find in the Java
      <filename>bin</filename> directory. In fact it is probably easier just
      to start it from the command line as discussed below.</para>

      <para>A more reliable, albeit low-level, approach is to start the slave
      from the command line. To do this, simply invoke the
      <command>javaws</command> executable from a command window as shown
      here:</para>

      <para><screen>C:&gt; javaws http://build.myorg.com/jenkins/computer/windows-slave-1/slave-agent.jnlp</screen>The
      exact command that you need to execute, including the correct URL, is
      conveniently displayed on the Jenkins slave node window just below the
      JNLP launch button (see <xref
      linkend="fig-jenkins-launch-jnlp" />).</para>

      <para>If security is activated on your Jenkins server, Jenkins will
      communicate with the slave on a specific non-standard port. If for some
      reason this port is inaccessible, the slave node will fail to start and
      will display an error message similar to the one shown in <xref
      linkend="fig-jenkins-slave-unable-to-connect" />.</para>

      <para><figure id="fig-jenkins-slave-agent">
          <title>The Jenkins slave agent in action</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-slave-unable-to-connect.png"
                         width="2.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>This is usually a sign that a firewall is blocking a port. By
      default, Jenkins picks a random port to use for TCP communication with
      it's slaves. However you can force Jenkins to use a fixed port in the
      System configuration screen by selecting 'Fixed' in the <command>TCP
      port for JNLP slave agents</command>, as shown in <xref
      linkend="fig-jenkins-tcp-ports" />. </para>

      <para><figure id="fig-jenkins-tcp-ports">
          <title>The Jenkins slave agent in action</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-tcp-ports.png"
                         width="8.3in" />
            </imageobject>
          </mediaobject>
        </figure>Once you have the slave up and running on your Windows
      machine, you can save yourself the bother of having to restart it
      manually each time your machine reboots by installing it as a Windows
      service. To do this, select the 'Install as Windows Service' menu option
      in the File menu of the slave agent window (see <xref
      linkend="fig-jenkins-install-slave-service" />). </para>

      <para><figure id="fig-jenkins-install-slave-service">
          <title>Installing the Jenkins slave as a Windows service</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-install-slave-service.png"
                         width="2.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>Once this is done, your Jenkins slave node will start
      automatically whenever the machine starts up, and can be administered
      just like any other Windows service (see <xref
      linkend="fig-jenkins-slave-service-installed" />).</para>

      <para><figure id="fig-jenkins-slave-service-installed">
          <title>Installing the Jenkins slave as a Windows service</title>

          <mediaobject>
            <imageobject role="web">
              <imagedata align="center"
                         fileref="figs/web/jenkins-slave-service-installed.png"
                         width="4.3in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </sect2>

    <sect2>
      <title>Starting the slave node in headless mode</title>

      <para>You can also start a slave agent in headless mode, directly from
      the command line. This is useful if you don't have a user interface
      available, for example if you are starting a JNLP slave node on a Unix
      machine. If you are working with Unix machines, it is generally easier
      and more flexible just to use an SSH connection, but there are sometimes
      network or architecture constraints that prevent you from using SSH. In
      cases like this, it is still possible to run a slave node from the
      command line. </para>

      <para>To start the slave node this way, you need to use Jenkin's
      <filename>slave.jar</filename> file. You can find this in
      <filename>JENKINS_HOME/war/WEB-INF/slave.jar</filename>. Once you have
      located this file, you can run it as follows:<screen>java -jar slave.jar \
 -jnlpUrl http://build.myorg.com/jenkins/computer/windows-slave-1/slave-agent.jnlp</screen></para>

      <para>And if your Jenkins server requires authentication, just pass in
      the <command>-auth username:password</command> option.</para>
    </sect2>
  </sect1>

  <sect1 id="node-monitoring">
    <title>Node monitoring</title>

    <para>Jenkins doesn't just dispatch build jobs to slave agents and hope
    for the best: it pro-actively monitors your slave machines, and will take
    a node offline if it considers that the node is incapable of safely
    performing a build. You can fine-tune exactly what Jenkins monitors int
    the 'Manage Nodes' screen (see <xref
    linkend="fig-jenkins-node-monitoring" />). Jenkins monitors the slave
    agents in several different ways. It monitors the response time: an overly
    slow response time can indicate either a network problem or that the slave
    machine is down. It also monitors the amount of disk space, temporary
    directory space and swap space available to the Jenkins user on the slave
    machine, since build jobs can be notoriously disk-hungry. It also keeps
    tabs on the system clocks, as if the cocks are not correctly synchronized,
    odd errors can sometimes happen. If any of these criteria is not up to
    scratch, Jenkins will automatically take the server offline.</para>

    <para><figure id="fig-jenkins-node-monitoring">
        <title>Jenkins pro-actively monitors your build agents</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata align="center"
                       fileref="figs/web/jenkins-node-monitoring.png"
                       width="4.3in" />
          </imageobject>
        </mediaobject>
      </figure></para>
  </sect1>

  <sect1 id="sect-build-jobs-conclusion">
    <title>Conclusion</title>

    <para>In this chapter we have covered the basics of creating new build
    jobs for the most common cases you are likely to encounter. Later on in
    the book, we will build on these foundations to discuss more advanced
    options such as parameterized builds, matrix builds, and build promotion
    strategies.</para>
  </sect1>
</chapter>
